{"meta":{"title":"Hexo","subtitle":"","description":"","author":"yango","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"2 数据结构","slug":"算法_数据结构/2.数据结构","date":"2021-01-18T14:44:52.897Z","updated":"2021-01-18T14:47:15.485Z","comments":true,"path":"2021/01/18/算法_数据结构/2.数据结构/","link":"","permalink":"http://example.com/2021/01/18/%E7%AE%97%E6%B3%95_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"数据结构介绍 定义：数据结构是指 相互之间存在着一种或多种关系 的 数据元素的集合 和 该集合中数据元素之间的关系组成。 简单说：数据结构就是设计数据以何什么方式组织并存储在计算机中 如：列表、集合、字典 N.Wirth: “程序 = 数据结构 + 算法” 数据结构的分类 数据结构按照其逻辑结构可分为：线性结构、树结构、图结构 线性结构：数据结构中的元素存在一对一的相互关系 树结构：数据结构中的元素存在一对多的相互关系 图结构：数据结构中的元素存在着多对多的相互关系 列表 最简单的线性结构 存储：顺序表，一块连续的内存 操作的时间复杂度： 查找：O(1) 由于python列表中可以存不同类型的数据， 所以实质：先为存入的元素分配内存，在将内存地址存入列表 插入(insert)：O(n) 删除(remove)：O(n) 1. 栈 栈的介绍 栈(Stack)是一个数据集合，可以理解为只能在一端进行插入或删除操作的列表。 特点：后进先出 （如堆叠的书本、进出电梯） 概念：栈顶、栈底 栈底：列表(list)最后一位 栈的基本操作： 进栈（压栈）：push 出栈：pop 取栈顶：gettop 栈的实现 使用一般的列表结构即可实现栈 * 进栈：`li.append` * 出栈：`li.pop` * 取栈顶：`li[-1]` 栈的应用 - 括号匹配 示例 括号匹配问题：给一个字符串，其中包含小括号、中括号、大括号，求该字符串中的括号是否匹配。 例如： 1234()()[]&#123;&#125; 匹配([&#123;()&#125;]) 匹配[]( 不匹配[(]) 不匹配 解决 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&quot;&quot;&quot;栈 - 括号匹配 ( 入栈 ) 出栈&quot;&quot;&quot;class Stack: def __init__(self): self.stack = [] def push(self, element): &quot;&quot;&quot;压栈&quot;&quot;&quot; self.stack.append(element) def pop(self): &quot;&quot;&quot;出栈&quot;&quot;&quot; try: name = self.stack.pop() return name except Exception as e: print(e) def get_top(self): &quot;&quot;&quot;栈顶&quot;&quot;&quot; if len(self.stack) &gt; 0: return self.stack[-1] return None def is_empty(self): return len(self.stack) == 0 def brace_mathc(s): match = &#123;&#x27;&#125;&#x27;:&#x27;&#123;&#x27;, &#x27;]&#x27;:&#x27;[&#x27;, &#x27;)&#x27;:&#x27;(&#x27;&#125; stack = Stack() for ch in s: if ch in [&#x27;(&#x27;, &#x27;[&#x27;, &#x27;&#123;&#x27;]: stack.push(ch) else: # ),],&#125; if stack.is_empty(): return False elif stack.get_top() == match[ch]: stack.pop() else: return False if stack.is_empty(): return True else: return False 2. 队列 队列的介绍 定义：队列(Queue)是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除 特点：先进先出 概念：队尾、队头 进行插入的一端称为队尾(rear)，插入的侗族称为进队或入队 进行删除的一端称为对头(front)，删除动作称为出队 队列的实现 由于简单队列，元素会自动补位，复杂度高，故不采用 采用环形队列实现 实现方式 环形队列：当队尾指针front == Maxsize -1时 ，再前进一个位置自动到0位 队首指针前进1：front = (front + 1) % Maxsize 队尾指针前进1：rear = (rear + 1) % Maxsize 队空条件：rear == front 队满条件：(rear + 1) % Maxsize == front 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&quot;&quot;&quot;实现队列复杂度为1：不自动补位 环形队列 front (front + 1) / size 从队 -1位 前进到 0位 队列性质：先进先出 进出队列，为指针指向位置 队尾(rear) 进 队首(front) 出rear == front 队列为空rear +1 = front 队列满了（留一空位不填充，做标识）&quot;&quot;&quot;class Queue: def __init__(self, size=100): self.queue = [0 for _ in range(size+1)] # 初始化固定长度 列表（0填充） self.size = size self.rear = -1 # 队尾指针 self.front = -1 # 队首指针 def push(self, element): if not self.is_full(): self.rear = (self.rear + 1) % self.size self.queue[self.rear] = element else: raise IndexError(&quot;Queue is full&quot;) def pop(self): if not self.is_empty(): self.front = (self.front + 1) % self.size return self.queue[self.front] # 移动指针，覆盖数值？ else: raise IndexError(&quot;Queue is empty&quot;) def is_empty(self): return self.rear == self.front def is_full(self): return (self.rear + 1) % self.size == self.frontif __name__ == &quot;__main__&quot;: q = Queue(5) for i in range(1,6): q.push(i) print(q.queue) print(len(q.queue)) 队列的内置模块 双向队列 性质：双向队列的两端都支持进队和出队 双向队列的基本操作： 队首进队 队首出队 队尾进队 队尾出队 注： queue模块用于保证线程安全 算法中，我们常使用 collections.deque 使用方法：from collections import deque 创建队列：queue = deque() 进队：append() 出队：popleft() 双向队列队首进队：appendleft() 双向队列队尾出队：pop() 123456&quot;&quot;&quot;queue模块用于保证 线程安全collections.deque： 算法的队列一般用它 是双向队列&quot;&quot;&quot; 3. 链表 定义： 链表是一种在存储单元上非连续、非顺序的存储结构。 链表由一系列节点组成的元素集合。 ​ 每个节点包含两部分： ​ 数据域或item 和 指向下一个节点的指针next。 ​ 通过节点之间的相互连接，最终串联成一个链表 1234567891011class Node(object): def __init__(self, item): self.item = item self.next = next # 连接节点a = Node(1)b = Node(2)c = Node(3)a.next = bb.next = c 创建链表（方法） 头插法 需知道头节点位置 尾插法 需知道头节点、尾节点位置 创建链表 代码的实现 1234class Node: def __init__(self, item): self.item = item self.next = None 头插法 12345678910111213def create_linklist_head(li): &quot;&quot;&quot; 头插法（只需维护头节点） :param li: :return: head &quot;&quot;&quot; head = Node(li[0]) for element in li[1:]: node = Node(element) node.next = head head = node return head 尾插法 1234567891011121314def create_linklist_tail(li): &quot;&quot;&quot; 尾插法（需维护头、尾节点） :param li: :return: head &quot;&quot;&quot; head = Node(li[0]) tail = head for element in li[1:]: node = Node(element) tail.next = node tail = node return head 链表的遍历 1234def print_linklist(lk): while lk: print(lk.item, end=&quot;, &quot;) lk = lk.next 单链表 链表节点的插入 插入4节点 ​ 关联 插队时并列节点的指向 让被插队的节点指向自己 12p.next = curNode.nextcurNode.next = p 链表节点的删除 删除4节点 定义 p指向要删除的节点 让自己的下一节点，指向自己的上一节点 删除p 123p = curNode.nextcurNode.next = curNode.next.nextdel p 双链表 双链表的每个节点有两个指针： ​ 一个指向后一个节点 ​ 另一个指向前一个节点 建立双链表 ​ 12345class Node(object): def __init__(self, item=None): self.item = item self.next = None self.prior = None 双链表节点的插入 1234p.next = curNode.nextcurNode.next.piror = pp.prior = curNodecurNode.next = p 双链表节点的删除 1234p = curNode.nextcurNode.next = p.nextp.next.piror = curNodedel p 链表复杂度分析 顺序表（列表/数组）与 链表 操作 顺序表 链表 按元素值查找 O(n) O(n) 按下标查找 O(1) O(n) 在某元素后插入 O(n) O(1) 删除某元素 O(n) O(1) 总结： 链表在插入和删除的操作上明显快于顺序表 链表的内存可以更灵活的分配 链表这种链式存储的数据结构对树和图的结构有很大的启发性 4. 哈希表 哈希表的介绍 哈希表 = 直接寻址表 + 哈希 定义：又称为散列表(Hash Table)，是一种线性表的存储结构。哈希表由一个直接寻址表和一个哈希函数组成。哈希函数h(k)将元素关键字k作为自变量，返回元素的存储下标。 特点：哈希表通过一个哈希函数来计算数据存储的位置的数据结构。通常支持如下操作： insert(key, value)：插入键值对 (key, value) get(key)：如果存在键为key的键值对则返回其value，否则返回空值 delete(key)：删除键为key的键值对 哈希表 = 直接寻址表 + 哈希 直接寻址表 当关键字的全域U比较小时，直接寻址时一种更简单而有效的方法 缺点： 当域U很大时，需要消耗大量内存，很不实际 如果域U很大而实际出现的key很少，则有大量空间被浪费 无法处理关键字不是数字的情况 哈希 直接寻址表：key为k的元素放到k位置上 改进直接寻址表：哈希 构建大小为m的寻址表T key为 k 的元素放到 h(k) 位置上 h(k) 是一个函数，其将域U映射到表[0,1,…,m-1] 哈希冲突 哈希函数对不对的key，映射出了相同的结果 解决冲突 —— 开放寻址法 如果哈希函数返回的位置已经有值，则可以向后探查新的位置来存储这个值。 线性查找：如果位置i被占用，则探查 i+1, i+2, … 二次查找：如果位置i被占用，则探查 i+1^2, i-1^2, i+2^2, … 二度哈希：有n个哈希函数，当使用 第1个哈希函数h1 发生冲突时，则尝试使用 h2, h3, … 解决冲突 —— 拉链法 哈希表的每个位置都链接一个链表，当发生冲突时，冲突的元素将被加到该位置链表的最后。 哈希表 —— 常见函数 除法哈希法： h(k) = k % m 乘法哈希法： h(k) = floor(m*(A*key%1)) 全域哈希法： 哈希表的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# 哈希表 基于链表进行插入# 哈希冲突——拉链法；重复的数放在以链表节点的形式添加在后面class LinkList: &quot;&quot;&quot;链表类&quot;&quot;&quot; class Node: def __init__(self, item=None): self.item = item self.next = None class LinkListIterator: &quot;&quot;&quot;迭代器类&quot;&quot;&quot; def __init__(self, node): self.node = node def __next__(self): if self.node: cur_node = self.node self.node = cur_node.next return cur_node.item else: raise StopIteration def __iter__(self): return self def __init__(self, iterable=None): self.head = None self.tail = None if iterable: self.extend(iterable) def append(self, obj): &quot;&quot;&quot;添加链表节点&quot;&quot;&quot; s = LinkList.Node(obj) if not self.head: self.head = s self.tail = s else: self.tail.next = s self.tail = s def extend(self, iterable): &quot;&quot;&quot;自动进行添加&quot;&quot;&quot; for obj in iterable: self.append(obj) def find(self, obj): &quot;&quot;&quot;查找&quot;&quot;&quot; for n in self: if n == obj: return True else: return False def __iter__(self): return self.LinkListIterator(self.head) def __repr__(self): &quot;&quot;&quot;打印&quot;&quot;&quot; return &quot;&lt;&lt;&quot; + &quot;, &quot;.join(map(str, self)) + &quot;&gt;&gt;&quot;class HashTable: def __init__(self, size=101): self.size = size # self.T = [None for i in range(self.size)] self.T = [LinkList() for i in range(self.size)] def h(self, k): return k % self.size def insert(self, k): i = self.h(k) # 去重 if self.find(k): print(&quot;Duplicated Insert.&quot;) else: self.T[i].append(k) def find(self, k): i = self.h(k) return self.T[i].find(k) 哈希表的应用 集合 字典 md5算法 曾经密码学中常用的哈希函数，将任意长度的数据映射为128为的哈希值 文件的哈希值（两个文件哈希值相同） 帮用户验证下载的文件是否完整 云存储商判断上传的文件是否存在于服务器上，从而实现妙传功能，避免存储过多相同的文件副本 SHA2算法 较安全性受到挑战的MD5合SHA-1，安全性较高 SHA-2包含一系列的哈希函数：SHA-224，SHA-256，SHA-384 。。。（数字对应哈希值长度） 挖矿（比特币） 5. 树 数的介绍 树与二叉树 树是一种数据结构。比如目录结构 树是一种可以递归定义的数据结构 树是由n个节点组成的集合： 如果n=0，拿这是一颗空树； 如果n&gt;0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树 树的一些概念： 根节点、叶子节点 树的深度 树的度：所有节点最大的度（节点的度：几个分叉） 孩子节点/父节点 子树 树的实例：模拟文件系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 节点属性# 类型：文件夹/文件# 存储方式：链式存储class Node: def __init__(self, name, type=&quot;dir&quot;): self.name = name self.type = type # &quot;dir&quot; or &quot;file&quot; self.children = [] self.parent = None def __str__(self): return self.name class FileSystemTree: def __init__(self): self.root = Node(&quot;/&quot;) self.now = self.root def mkdir(self, name): # name 以/结尾 if name[-1] != &quot;/&quot;: name += &quot;/&quot; node = Node(name) self.now.children.append(node) node.parent = self.now def ls(self): return self.now.children def cd(self, name): if name[-1] != &quot;/&quot;: name += &quot;/&quot; if name == &quot;../&quot;: self.now = self.now.parent return for child in self.now.children: if child.name == name: self.now == child return raise ValueError(&quot;invalid dir&quot;) if __name__ == &quot;main&quot;: tree = FileSystemTree() tree.mkdir(&quot;var/&quot;) print(tree.root.children) 二叉树 定义：树的度为2（两个节点）的树 二叉树的链式存储：将二叉树的节点定义为一个对象，节点之间通过类似链表的连接方式来连接。 节点定义 12345678910111213141516171819202122class BiTreeNode: def __init__(self, data): self.data = data self.lchild = None self.rchild = None a = BiTreeNode(&quot;A&quot;)b = BiTreeNode(&quot;B&quot;)c = BiTreeNode(&quot;C&quot;)d = BiTreeNode(&quot;D&quot;)e = BiTreeNode(&quot;E&quot;)f = BiTreeNode(&quot;F&quot;)g = BiTreeNode(&quot;G&quot;)e.lchild = ae.rchild = ga.lchild = cc.lchild = bc.rchild = dg.rchild = froot = e 二叉树的遍历 4种遍历方式： 前序遍历：EACBDGF 123456789101112# 1 自己# 2 左子树# 3 右子树def pre_order(root): if root: print(root.data, end=&quot;,&quot;) pre_order(root.lchild) pre_order(root.rchild)if __name__ == &quot;main&quot;: pre_order(root) # E,A,C,B,D,G,F, 中序遍历：ABCDEGF 123456789# 1 左子树# 2 自己# 3 右子树def in_order(root): if root: pre_order(root.lchild) print(root.data, end=&quot;,&quot;) pre_order(root.rchild) 后序遍历：BDCAFGE 12345678910# 1 左# 2 右# 3 自己def post_order(root): &quot;&quot;&quot;中序遍历&quot;&quot;&quot; if root: post_order(root.lchild) post_order(root.rchild) print(root.data, end=&quot;,&quot;) 层次遍历 ：EAGCFBD 12345678910111213141516171819# 使用队列# 进主节点 # 出主 # 有子节点 —— 进子 from collections import dequedef level_order(root): &quot;&quot;&quot;层级遍历&quot;&quot;&quot; q = deque() q.append(root) while len(q) &gt; 0: node = q.popleft() print(node.data, end=&quot;, &quot;) if node.lchild: q.append(node.lchild) if node.rchild: q.append(node.rchild) 二叉搜索树 定义：二叉搜索树是一棵二叉树，且满足性质： ​ 设x是二叉树的一个节点。 ​ 如果y是x左子树的一个节点，那么 y.key &lt;= x.key； ​ 如果y是x右子树的一个节点：那么y.key &gt;= x.key 二叉搜索树的操作：查询、插入、删除 AVL树 windows对进程地址空间的管理用到了AVL树。","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"3 算法进阶","slug":"算法_数据结构/3.算法进阶","date":"2021-01-18T14:44:52.892Z","updated":"2021-01-18T14:47:05.972Z","comments":true,"path":"2021/01/18/算法_数据结构/3.算法进阶/","link":"","permalink":"http://example.com/2021/01/18/%E7%AE%97%E6%B3%95_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/","excerpt":"","text":"1. 贪心算法 定义：贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最有上加以考虑，他所做出的是在某种意义上的最优解。 注：贪心不保证最优解，但在特定的问题上可以有最优解（该问题能用贪心算法计算） 示例 1. 找零问题 假设商店老板需要找零n元钱，钱币的面额有：100元、50元、20元、5元、1元，如何找零使得所需钱币的数量最少？ 1234567891011121314151617# 优先找大面额的t = [100, 50, 20, 5, 1]def change(n): &quot;&quot;&quot; :param n: 需找零钱数 :return: m：找零面额对应数值；n：未找开的 &quot;&quot;&quot; m = [0 for _ in range(len(t))] for i, money in enumerate(t): m[i] = n // money n = n % money return m, nif __name__ == &#x27;__main__&#x27;: print(change(599)) 2. 分数背包 一个小偷在某商店发现有n个商品，第i个商品价值v_i元，重w_i千克。他希望拿走的价值尽量高，但他的背包最多只能容纳W千克的东西。他应该拿走那些商品 两种情况： 0-1背包：对于一个商品，小偷要么把她完整拿走，要么留下。不敢只拿走一部分，或把一个商品拿走多次。（商品为金条） 分数背包：对于一个商品，小偷可以拿走其中任意一部分。（商品为金砂） 若： 商品1：v1=60 w1=10 商品2：v2=100 w2=20 商品3：v3=120 w3=30 背包容量：W=50 问：对于0-1背包和分数背包，贪心算法是否都能得到最优解？为什么？ 12345678910111213141516171819202122232425262728293031# 分数背包：单位重量# 0-1背包，数量级小，难以取整，有剩余容量# 优先 价格高# 满足 总重量=Wgoods = [(60, 10), (100, 20), (120, 30)] # 每个商品元组表示（价格，重量）def fractional_backpack(goods, w): goods.sort(key=lambda x: x[0]/x[1], reverse=True) m = [0 for _ in range(len(goods))] totoal_v = 0 for i, (price, weight) in enumerate(goods): if w &gt;= weight: m[i] = 1 w -= weight totoal_v += price else: m[i] = w / weight totoal_v += m[i] * price w = 0 break return m, totoal_vif __name__ == &#x27;__main__&#x27;: ret = fractional_backpack(goods, 50) print(ret) 3. 数字拼接问题 有n个非负整数，将其按照字符串拼接的方式拼接成一个整数。如何拼接可以使得得到的整数最大？ 例：32, 94, 128, 1286, 6, 71可以拼接出的最大整数为94716321286128 123456789# 94 71 6 32 1286 128# 94 71 6 32 128 1286# 第一位：首位最大# 其他位： 128为1286的子串: 1286128 &gt; 1281286 728为1786的字串: 7287286 &gt; 7286728# 使用字符串拼接比较x+y if x+y &gt; y+x else y+x my_version 12345678910111213&quot;&quot;&quot;普通排序&quot;&quot;&quot;def number_join(li): li = list(map(str, li)) # 交换 for x in range(len(li) - 1): for y in range(x + 1, len(li)): if li[x] + li[y] &lt; li[y] + li[x]: li[x], li[y] = li[y], li[x] return li my_优化 12345678910111213141516171819202122232425262728293031323334353637# 优化排序：快排def partition(li, left, right): &quot;&quot;&quot; 归位 :param li: :param left: 左指针 :param right: 右指针 :return: 归位后p的下标 循环退出条件：left = right &quot;&quot;&quot; tmp = li[left] while left &lt; right: while left &lt; right and li[right] + tmp &lt;= tmp + li[right]: # 从右找比tmp小的数 right -= 1 li[left] = li[right] while left &lt; right and li[left] + tmp &gt;= tmp + li[left]: left += 1 li[right] = li[left] li[left] = tmp # 循环终止，left=right return leftdef _quick_sort(li, left, right): if left &lt; right: mid = partition(li, left, right) # 归位 _quick_sort(li, left, mid - 1) _quick_sort(li, mid + 1, right)@cal_timedef number_join3(li): li = list(map(str, li)) _quick_sort(li, 0, len(li) - 1) return &quot;&quot;.join(li) luffy_优解 1234567891011121314151617n = [32, 94, 128, 1286, 6, 71]from functools import cmp_to_keydef xy_cmp(x, y): if x + y &lt; y + x: return 1 elif x + y &gt; y + x: return -1 else: return 0def number_join2(li): li = list(map(str, li)) li.sort(key=cmp_to_key(xy_cmp)) return &quot;&quot;.join(li) 总结： 速度：python内置sort(归并) &lt; 快排 &lt; 普通排序（sort与快排较接近） 4. 活动选择问题 假设有n个活动，这些活动要占用同一片场地，而场地在某时刻只能供一个活动使用。 每个活动都有一个开始时间s_i和结束时间f_i（题目中时间以整数表示），表示活动在 [s_i, f_i) 区间占用场地。 问：安排那些活动能够使该场地举办的活动的个数最多 ？ 1234567891011121314151617181920# 贪心结论：最先结束的活动 为最优解的一部分activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]# 按先结束的场次排序activities.sort(key=lambda x: x[1])def activity_selection(li): res = [li[0]] # 第一个时间一定在里面 for i in range(1, len(li)): if li[i][0] &gt;= res[-1][1]: # 当前活动的开始时间 &lt;= 最后一个入选的结束时间 res.append(li[i]) return resif __name__ == &quot;main&quot;: ret = activity_selection(activities) print(ret, len(ret)) # [(1, 4), (5, 7), (8, 11), (12, 16)] 4 2. 动态规划 从斐波那契看动态规划 斐波那契数列：F_n = F_n-1 + F_n-2 使用递归和非递归的方法来求解斐波那契数列的第n项 递归 123456# 递归def fibnacci(n): if n == 1 or n == 2: return 1 else: return fibnacci(n - 1) + fibnacci(n - 2) 非递归 12345678# 非递归def fibnacci_no_recurision(n): f = [0,1,1] if n &gt; 2: for i in range(n-2): num = f[-1] + f[-2] f.append(num) return f[n] 结论： 求斐波那契(时间)：非递归 &lt; 递归 ​ 递归算法出现大量重复计算，大大降低了运行的效率 动态规划（DP）的思想 = 递归式 + 重复子问题 动态规划问题关健特征 可用动态规划方法解决的问题 最有子结构 原问题的最优解种设计多少个问问题 在确定最优解使用哪些问题时，需要考虑多少种选择 重叠子问题 示例： 1. 钢条切割问题 某公司出售钢条，出售价格与钢条长度之间的关系如下表： 问题：现有一段长度为n的钢条和上面的价格表，求切分钢条方案，使得总收益最大。 递推式 1: 递归（自上而下） rn=maxi=1n(pn,r1+rn−1+...+ri+rn−i)r_n = max_{i=1}^{n}(p_n, r_1 + r_{n-1} + ... + r_i + r_{n-i}) rn​=maxi=1n​(pn​,r1​+rn−1​+...+ri​+rn−i​) 12345678def cut_rod_recursion_1(p, n): if n == 0: return 0 else: res = p[n] for i in range(1, n): res = max(res, cut_rod_recursion_1(p, i) + cut_rod_recursion_1(p, n-i)) return res 递推式 2: 递归（自上而下） rn=maxi=1n(pi,rn−1)r_n = max_{i=1}^{n}(p_i, r_{n-1}) rn​=maxi=1n​(pi​,rn−1​) 12345678def cut_rod_recursion_2(p, n): if n == 0: return 0 else: res = 0 for i in range(1, n): res = max(res, p[i] + cut_rod_recursion_1(p, n-i)) return res 动态规划 - 自下而上 12345678def cut_rod_dp(p, n): r = [0] for i in range(1, n+1): res=0 for j in range(1, i+1): res = max(res, p[j] + r[i - j]) r.append(res) return r[n] 总结 123456# 递归-自上而下# 时间复杂度：O(2^n)# 动态规划-自下而上# 时间复杂度：O(n^2) 最优解基础上 — 输出切分方案 123456789101112131415161718192021222324252627282930def cut_rod_extend(p, n): &quot;&quot;&quot; :return: 最优切割价格，左段（!=0） &quot;&quot;&quot; r = [0] s = [0] for i in range(1,n+1): res_r = 0 # 价格的最大值 res_s = 0 # 价格最大值对应方案的左边（不切分部分的长度） for j in range(1, i+1): if p[j] + r[i-j] &gt; res_r: res_r = p[j] + r[i-j] res_s = j r.append(res_r) s.append(res_s) return r[n], sdef cut_rod_solution(p,n): r,s = cut_rod_extend(p, n) ans = [] while n &gt; 0: ans.append(s[n]) n -= s[n] return ansif __name__ == &#x27;__main__&#x27;: ret = cut_rod_solution(p, 5) print(ret) # [2, 3] 2. 最长公共子序列 子序列：一个序列的子序列是在该序列不改变原序列顺序 的情况下 从序列中 删去若干元素后得到的序列（不连续） ​ 例：“ABCD”和“BDF”都是“ABCDEFG”的子序列 子串： 指一个字符串删掉其部分前缀和后缀（也可以不删）后形成的字符串。（连续性） 应用场景：字符串相似度比对，基因工程比对 最长公共子序列问题（LCS）问题：给定两个序列X和Y，求X和Y长度最大的公共子序列 ​ 例：X = “ABBCBDE” Y=“DBBCDB” LCS(X,Y) = “BBCD” 递推式： c[i,j]={0i=0 或 j=0c[i−1,j−1]+1i,j&gt;0 且 xi≠yimax(c[i,j−1], c[i−1,j])i,j&gt;0 且 xi≠yic[i,j] = \\begin{cases} 0 \\quad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad i=0\\;或\\;j=0\\\\ c[i-1,j-1] + 1 \\qquad\\qquad\\qquad i,j&gt;0 \\; 且 \\; x_i\\neq y_i\\\\ max(c[i,j-1],\\;c[i-1,j]) \\qquad i,j&gt;0 \\;且 \\; x_i\\neq y_i\\\\ \\end{cases} c[i,j]=⎩⎪⎨⎪⎧​0i=0或j=0c[i−1,j−1]+1i,j&gt;0且xi​​=yi​max(c[i,j−1],c[i−1,j])i,j&gt;0且xi​​=yi​​ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# 求X和Y长度最大的公共子序列的 长度def lcs_length(x, y): &quot;&quot;&quot; :param x: 序列1 :param y: 序列2 :return: 最大公共子序列长度 &quot;&quot;&quot; m = len(x) n = len(y) c = [[0 for _ in range(n+1)] for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if x[i-1] == y[j-1]: c[i][j] = c[i-1][j-1] + 1 else: c[i][j] = max(c[i-1][j], c[i][j-1]) return c[m][n]# 求序列 - 回溯def lcs(x, y): &quot;&quot;&quot; :param x: 序列1 :param y: 序列2 :return: 最大公共子序列长度; 箭头匹配 &quot;&quot;&quot; m = len(x) n = len(y) c = [[0 for _ in range(n + 1)] for _ in range(m + 1)] b = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # 指箭头 1左上方 2上方 3左方 # b = [[&quot;&quot; for _ in range(n + 1)] for _ in range(m + 1)] # 指箭头 1左上方 2上方 3左方 for i in range(1, m + 1): for j in range(1, n + 1): if x[i - 1] == y[j - 1]: c[i][j] = c[i - 1][j - 1] + 1 b[i][j] = 1 # b[i][j] = &quot;↖&quot; elif c[i - 1][j] &gt; c[i][j - 1]: c[i][j] = c[i - 1][j] b[i][j] = 2 # b[i][j] = &quot;↑&quot; else: c[i][j] = c[i][j - 1] b[i][j] = 3 # b[i][j] = &quot;←&quot; return c[m][n], bdef lcs_trackback(x, y): &quot;&quot;&quot; :param x: 序列1 :param y: 序列2 :return: 最大公共子序列（其中一种，最长可能有多个） &quot;&quot;&quot; c, b = lcs(x, y) i = len(x) j = len(y) res = [] while i&gt;0 and j&gt;0: if b[i][j] == 1: # # 来自左上方—— 匹配 res.append(x[i-1]) i -= 1 j -= 1 elif b[i][j] == 2: # 来自上方——不匹配 i -= 1 else: # 来自左方——不匹配 j -= 1 return &quot;&quot;.join(reversed(res))if __name__ == &#x27;__main__&#x27;: x = &quot;ABBCBDE&quot; y = &quot;DBBCDB&quot; # ret = lcs_length(x, y) # 4 # c, b = lcs(x, y) # for _ in b: # print(_) ret = lcs_trackback(x,y) print(ret) # BBCD 3. 欧几里得算法 最大公约数 约数：如果整数a能被整数b整除，那么a叫做b的倍数，b叫做a的约数 最大公约数：给定两个整数a,b，两个数的所有公共公约数中的最大值即为最大公约数 计算两个数的最大公约数： 欧几里得：辗转相除法 12345678910111213141516171819gcd(a,b) = gcd(b, a mod b)gcd(60, 21) = gcd(21, 18) = gcb(3, 0) = 0# 递归def gcd(a, b): if b == 0: return a else: return gcd(b, a % b)# 非递归def gcd2(a, b): while b&gt;0: r = a % b a = b b = r return a 《九章算术》：更相减损术 4. RSA算法 密码与加密 传统密码：加密算法是秘密的 现代密码系统：加密算法是公开的，密钥是秘密的 对称加密 非对称加密 RSA加密算法（非对称加密系统）： 公钥：用来加密，是公开的 私钥：用来解密，是私有的","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"","slug":"算法_数据结构/1.查找和排序","date":"2021-01-18T14:40:46.308Z","updated":"2020-12-24T08:31:53.156Z","comments":true,"path":"2021/01/18/算法_数据结构/1.查找和排序/","link":"","permalink":"http://example.com/2021/01/18/%E7%AE%97%E6%B3%95_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F/","excerpt":"","text":"查找和排序 递归 汉诺塔问题 查找 顺序查找（线性查找） 定义：从列表第一个元素开始，顺序进行搜索，直到找到元素或搜索道列表最后一个元素为止 时间复杂度：O(n) 123456def linear_search(li, val): for i in range(len(li)-1): if li[i] == val: return i return 二分查找 条件：有序列表 时间复杂度：O(logn) 1234567891011121314# li为有序列表def binary_search(li, val): left = 0 right = len(li) - 1 while left &lt;= right: mid = (left + right) // 2 if li[mid] == val: return mid elif li[mid] &lt; val: # 右侧查找 left = mid + 1 else: right = mid - 1 return False 排序 常见排序算法 简单排序 高效排序 其他 冒泡排序 快速排序 希尔排序 选择排序 堆排序 计数排序 插入排序 归并排序 基数排序 注： ​ 稳定的排序：冒泡排序、插入排序(摸牌)、归并排序 ​ 稳定性：挨个移动位置的都是稳定，不挨个换的不稳定 高效排序 三种算法的时间复杂度都是 O(n*logn) 一般情况下，就运行时间而言： 快速排序 &lt; 归并排序 &lt; 堆排序 三种算法缺点： 快速排序：极端情况下排序效率低 归并排序：需要额外的内存开销 堆排序：在快的排序算法中相对较慢 冒泡排序 定义：列表每2个相邻的数，如果前面比后面大，则两数交换位置 特点：一趟排序，无序区减少1个数，有序区增加一个数 递增列表：一趟向队尾冒一个大值（趟数↑ 值↓） 时间复杂度：O(n^2) 注：可优化 因每趟比较好，末尾有序数+1，所以下一次可少比较一位：j =&gt; range(len(li)-i-1) 设立 flag=False 若该趟比较后，列表排序位置不变，可直接进入下一次 12345678910def bubble_sort(li): for i in range(len(li) - 1): # 第i趟 flag = False for j in range(len(li)-i-1): # 下标j做比较(指针) if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1], li[j] flag = True if not flag: return 选择排序 循环遍历一次，取得最小数放第一位（有序区） 再从无序区取得最小数，放第2位。。。以此类推 时间复杂度：O(n^2) 12345678def select_sort(li): for i in range(len(li)): # 下标0~8i for j in range(i+1, len(li)): # 无序区 tmp = li[j] if li[j] &lt; li[i]: li[j] = li[i] li[i] = tmp 优化 由于第7次比较时，已完成最后一次交换（可省去一轮） 1234567def select_sort(li): for i in range(len(li)-1): # 下标0~8i for j in range(i+1, len(li)): # 无序区 # tmp = li[j] if li[j] &lt; li[i]: li[j], li[i] = li[i],li[j] 插入排序 扑克插牌，每摸一张牌，和手里的牌作比较：小的往前放，大的向后放 空间复杂度：O(n^2) 12345678910111213141516171819202122&quot;&quot;&quot; 手牌初始：0 摸牌 1~8 次 比较手牌： 比手牌小，左移 和次牌比-小 左移 比手牌大，放右 关系： 无序区：len(li) -i 有序区(0~8)：i - 1 指针j = i - 1 &quot;&quot;&quot; for i in range(1, len(li)): j = i - 1 my_turn = li[i] while my_turn &lt; li[j] and j&gt;=0 : li[j+1] = li[j] li[j] = my_turn # 优化：可以和else合并 j -= 1 else: # my_turn &gt; li[j] li[j+1] = my_turn 优化版 12345678def insert_sort(li): for i in range(1, len(li)): # 摸牌次数 共8次 tmp = li[i] j = i - 1 # 已有的手牌（有序） while j &gt;= 0 and tmp &lt; li[j]: # 摸的牌比手中的小，(朝左)交换位置 li[j+1] = li[j] j = j - 1 # 摸牌 和 此位的牌比 li[j+1] = tmp 快速排序 取第一个元素p，循环遍历比较，使p归位置 取p两端 各和p比较 ，排序：左边都比p小，右边都比p大 递归 时间复杂度：O(n*logn) (因涉及到递归，不严谨推导) 缺点： 递归耗费系统资源 最坏情况：(倒叙列表) [9, 8, 7, 6, 5, 4, 3, 2, 1] 每次移动一位 解决办法：随机找一个数和第一个数交换 快速排序 - 框架 12345678910111213141516171819202122232425262728def quick_sort(data, left, right): if left &lt; right: mid = partition(data, left, right) # 归位 quick_sort(data, left, mid-1) quick_sort(data, mid+1, right) def partition(li, left, right): &quot;&quot;&quot; 归位 :param li: :param left: 左指针 :param right: 右指针 :return: 归位后p的下标 &quot;&quot;&quot; tmp = li[left] while left &lt; right: while left &lt; right and li[right] &gt;= tmp: # 从右找比tmp小的数 right -= 1 # 往左走 li[left] = li[right] # 找到后，填补空位（左） while left &lt; right and li[left] &lt;= tmp: left += 1 li[right] = li[left] # 找到后，填补空位（右） li[left] = tmp # 循环终止，left=right return left 堆排序 归并排序 python内部sort()方法基于归并排序 特点 分解 =&gt; 有序 归并（需用新列表储存） 步骤： 分解：将列表越分越小，直至分成一个元素。 终止条件：一个元素是有序的 合并：将两个有序列表归并，列表越来越大。 什么是归并？ 假设列表中分为两段有序，如何将其合并成一个有序列表 归并(merge)：左右两段 分别取出 元素进行比较 (从左至右取出)，小的数先出来， 123456789101112131415161718192021222324252627282930313233343536373839def merge(li, low, mid, high): &quot;&quot;&quot; 合并（对有序的左右两段 归并） :return: 新的 有序列表 &quot;&quot;&quot; i = low j = mid + 1 ltmp = [] while i &lt;= mid and j &lt;= high: # 只要左右两边都有数 if li[i] &lt; li[j]: ltmp.append(li[i]) i += 1 else: ltmp.append(li[j]) j += 1 # print(ltmp) # 执行完以上代码，有一端没有数了 while i &lt;= mid: ltmp.append(li[i]) i += 1 while j &lt;= high: ltmp.append(li[j]) j += 1 li[low:high + 1] = ltmpdef merge_sort(li, low, high): &quot;&quot;&quot; 归并排序 1. 分解（递归） 2. 归并 &quot;&quot;&quot; if low &lt; high: # 至少2个元素 # 分解 mid = (low + high) // 2 merge_sort(li, low, mid) merge_sort(li, mid + 1, high) # 合并 merge(li, low, mid, high) 希尔排序 定义：是一种分组插入排序算法（插入排序的变形） 123456&quot;&quot;&quot;注： gap对半分组，为希尔排序的一种 希尔排序按gap区分，可通过优化gap序列，来提升时间复杂度&quot;&quot;&quot; 特点： 分组：再每趟基础上分组 d1 = n//2 d2 = d1/2 d3 = d2/2 … 最后一趟：只有一个元素 排序： 每趟并不使得某些元素有序，而是使整体数据越来越接近有序； 最后一趟排序使得所有数据有序 时间复杂度： 希尔排序的运行效率有gap序列决定，不同序列分组，有不一样的结果，较为复杂 效率：低于堆排序 ​ 分组 &amp; 排序 插入排序变形版 12345678910111213141516171819def insert_sort_gap(li, gap): &quot;&quot;&quot;分组 + 插入排序&quot;&quot;&quot; for i in range(gap, len(li)): tmp = li[i] j = i - gap while j &gt;= 0 and li[j] &gt; tmp: li[j + gap] = li[j] j -= gap # 与分到的组中的数作比较 gap：组间隔距离 else: li[j + gap] = tmp print(li)def shell_sort(li): &quot;&quot;&quot;希尔排序&quot;&quot;&quot; d = len(li) // 2 while d &gt;= 1: insert_sort_gap(li, d) d //= 2 整合版 1234567891011def shell_sort(li): gap = len(li) // 2 while gap &gt; 0: for i in range(gap, len(li)): tmp = li[i] j = i - gap while j &gt;= 0 and tmp &lt; li[j]: li[j+gap] = li[j] j -= gap li[j+gap] = tmp gap /= 2 计数排序 对列表进行排序，已知列表中的数范围都在 0~100 之间。设计时间复杂度为 O(n) 的算法 前提条件：已知列表中的数范围 时间复杂度：O(n) ​ * 快于python的sort(O*(nlogn))排序 12345678def count_sort(li, max_count=100): count = [0 for _ in range(max_count+1)] for val in li: # O(n) count[val] += 1 li.clear() for ind, val in enumerate(count): # O(n) for i in range(val): li.append(ind) 桶排序 基数排序 补充 设置递归最大深度 123import syssys.setrecursionlimit(10000)","categories":[],"tags":[]},{"title":"9-2 SQLAlchemy","slug":"flask/9-2 总结_SQLAlchemy","date":"2021-01-18T11:39:27.135Z","updated":"2021-01-18T14:10:26.600Z","comments":true,"path":"2021/01/18/flask/9-2 总结_SQLAlchemy/","link":"","permalink":"http://example.com/2021/01/18/flask/9-2%20%E6%80%BB%E7%BB%93_SQLAlchemy/","excerpt":"","text":"1.介绍 SQLAlchemy是一个基于Python实现的ORM框架。该框架建立在 DB API之上，使用关系对象映射进行数据库操作，简言之便是：将类和对象转换成SQL，然后使用数据API执行SQL并获取执行结果。 1pip3 install sqlalchemy 组成部分： 12345Engine，框架的引擎Connection Pooling ，数据库连接池Dialect，选择连接数据库的DB API种类Schema/Types，架构和类型SQL Exprression Language，SQL表达式语言 SQLAlchemy本身无法操作数据库，其必须以来pymsql等第三方插件，Dialect用于和数据API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作，如： 12345678910111213MySQL-Python mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt; pymysql mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;] MySQL-Connector mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt; cx_Oracle oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value...] 更多：http://docs.sqlalchemy.org/en/latest/dialects/index.html django中如何反向生成models 1python manage.py inspectdb &gt; app/models.py 2.简单使用（能创建表，删除表，不能修改表） 修改表：在数据库添加字段，类对应上 1执行原生sql（不常用） 123456789101112131415161718192021222324252627import timeimport threadingimport sqlalchemyfrom sqlalchemy import create_enginefrom sqlalchemy.engine.base import Engineengine = create_engine( &quot;mysql+pymysql://root:123456@127.0.0.1:3306/test?charset=utf8&quot;, max_overflow=0, # 超过连接池大小外最多创建的连接 pool_size=5, # 连接池大小 pool_timeout=30, # 池中没有线程最多等待的时间，否则报错 pool_recycle=-1 # 多久之后对线程池中的线程进行一次连接的回收（重置）)def task(arg): conn = engine.raw_connection() cursor = conn.cursor() cursor.execute( &quot;select * from app01_book&quot; ) result = cursor.fetchall() print(result) cursor.close() conn.close()for i in range(20): t = threading.Thread(target=task, args=(i,)) t.start() 2 orm使用 models.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import datetimefrom sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime, UniqueConstraint, IndexBase = declarative_base()class Users(Base): __tablename__ = &#x27;users&#x27; # 数据库表名称 id = Column(Integer, primary_key=True) # id 主键 name = Column(String(32), index=True, nullable=False) # name列，索引，不可为空 # email = Column(String(32), unique=True) #datetime.datetime.now不能加括号，加了括号，以后永远是当前时间 # ctime = Column(DateTime, default=datetime.datetime.now) # extra = Column(Text, nullable=True) __table_args__ = ( # UniqueConstraint(&#x27;id&#x27;, &#x27;name&#x27;, name=&#x27;uix_id_name&#x27;), #联合唯一 # Index(&#x27;ix_id_name&#x27;, &#x27;name&#x27;, &#x27;email&#x27;), #索引 )def init_db(): &quot;&quot;&quot; 根据类创建数据库表 :return: &quot;&quot;&quot; engine = create_engine( &quot;mysql+pymysql://root:123456@127.0.0.1:3306/aaa?charset=utf8&quot;, max_overflow=0, # 超过连接池大小外最多创建的连接 pool_size=5, # 连接池大小 pool_timeout=30, # 池中没有线程最多等待的时间，否则报错 pool_recycle=-1 # 多久之后对线程池中的线程进行一次连接的回收（重置） ) Base.metadata.create_all(engine)def drop_db(): &quot;&quot;&quot; 根据类删除数据库表 :return: &quot;&quot;&quot; engine = create_engine( &quot;mysql+pymysql://root:123456@127.0.0.1:3306/aaa?charset=utf8&quot;, max_overflow=0, # 超过连接池大小外最多创建的连接 pool_size=5, # 连接池大小 pool_timeout=30, # 池中没有线程最多等待的时间，否则报错 pool_recycle=-1 # 多久之后对线程池中的线程进行一次连接的回收（重置） ) Base.metadata.drop_all(engine)if __name__ == &#x27;__main__&#x27;: # drop_db() init_db() app.py 123456789101112131415161718from sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_enginefrom models import Users#&quot;mysql+pymysql://root@127.0.0.1:3306/aaa&quot;engine = create_engine(&quot;mysql+pymysql://root:123456@127.0.0.1:3306/aaa&quot;, max_overflow=0, pool_size=5)Connection = sessionmaker(bind=engine)# 每次执行数据库操作时，都需要创建一个Connectioncon = Connection()# ############# 执行ORM操作 #############obj1 = Users(name=&quot;lqz&quot;)con.add(obj1)# 提交事务con.commit()# 关闭session，其实是将连接放回连接池con.close() 3.一对多关系 12345678910111213141516class Hobby(Base): __tablename__ = &#x27;hobby&#x27; id = Column(Integer, primary_key=True) caption = Column(String(50), default=&#x27;篮球&#x27;)class Person(Base): __tablename__ = &#x27;person&#x27; nid = Column(Integer, primary_key=True) name = Column(String(32), index=True, nullable=True) # hobby指的是tablename而不是类名，uselist=False hobby_id = Column(Integer, ForeignKey(&quot;hobby.id&quot;)) # 跟数据库无关，不会新增字段，只用于快速链表操作 # 类名，backref用于反向查询 hobby=relationship(&#x27;Hobby&#x27;,backref=&#x27;pers&#x27;) 4.多对多关系 123456789101112131415161718192021class Boy2Girl(Base): __tablename__ = &#x27;boy2girl&#x27; id = Column(Integer, primary_key=True, autoincrement=True) girl_id = Column(Integer, ForeignKey(&#x27;girl.id&#x27;)) boy_id = Column(Integer, ForeignKey(&#x27;boy.id&#x27;))class Girl(Base): __tablename__ = &#x27;girl&#x27; id = Column(Integer, primary_key=True) name = Column(String(64), unique=True, nullable=False)class Boy(Base): __tablename__ = &#x27;boy&#x27; id = Column(Integer, primary_key=True, autoincrement=True) hostname = Column(String(64), unique=True, nullable=False) # 与生成表结构无关，仅用于查询方便,放在哪个单表中都可以 servers = relationship(&#x27;Girl&#x27;, secondary=&#x27;boy2girl&#x27;, backref=&#x27;boys&#x27;) 5.操作数据表 123456789101112131415161718from sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_enginefrom models import Users engine = create_engine(&quot;mysql+pymysql://root:123456@127.0.0.1:3306/aaa&quot;, max_overflow=0, pool_size=5)Session = sessionmaker(bind=engine) # 每次执行数据库操作时，都需要创建一个sessionsession = Session() # ############# 执行ORM操作 #############obj1 = Users(name=&quot;lqz&quot;)session.add(obj1) # 提交事务session.commit()# 关闭sessionsession.close() 6.基于scoped_session实现线程安全 1234567891011121314151617181920212223242526272829303132from sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_enginefrom sqlalchemy.orm import scoped_sessionfrom models import Usersengine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6&quot;, max_overflow=0, pool_size=5)Session = sessionmaker(bind=engine)&quot;&quot;&quot;# 线程安全，基于本地线程实现每个线程用同一个session# 特殊的：scoped_session中有原来方法的Session中的一下方法：public_methods = ( &#x27;__contains__&#x27;, &#x27;__iter__&#x27;, &#x27;add&#x27;, &#x27;add_all&#x27;, &#x27;begin&#x27;, &#x27;begin_nested&#x27;, &#x27;close&#x27;, &#x27;commit&#x27;, &#x27;connection&#x27;, &#x27;delete&#x27;, &#x27;execute&#x27;, &#x27;expire&#x27;, &#x27;expire_all&#x27;, &#x27;expunge&#x27;, &#x27;expunge_all&#x27;, &#x27;flush&#x27;, &#x27;get_bind&#x27;, &#x27;is_modified&#x27;, &#x27;bulk_save_objects&#x27;, &#x27;bulk_insert_mappings&#x27;, &#x27;bulk_update_mappings&#x27;, &#x27;merge&#x27;, &#x27;query&#x27;, &#x27;refresh&#x27;, &#x27;rollback&#x27;, &#x27;scalar&#x27;)&quot;&quot;&quot;#scoped_session类并没有继承Session,但是却又它的所有方法session = scoped_session(Session)# ############# 执行ORM操作 #############obj1 = Users(name=&quot;alex1&quot;)session.add(obj1)# 提交事务session.commit()# 关闭sessionsession.close() 7.基本增删查改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import timeimport threadingfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Indexfrom sqlalchemy.orm import sessionmaker, relationshipfrom sqlalchemy import create_enginefrom sqlalchemy.sql import textfrom db import Users, Hostsengine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6&quot;, max_overflow=0, pool_size=5)Session = sessionmaker(bind=engine)session = Session()# ################ 添加 ################&quot;&quot;&quot;obj1 = Users(name=&quot;wupeiqi&quot;)session.add(obj1)session.add_all([ Users(name=&quot;lqz&quot;), Users(name=&quot;egon&quot;), Hosts(name=&quot;c1.com&quot;),])session.commit()&quot;&quot;&quot;# ################ 删除 ################&quot;&quot;&quot;session.query(Users).filter(Users.id &gt; 2).delete()session.commit()&quot;&quot;&quot;# ################ 修改 ################&quot;&quot;&quot;#传字典session.query(Users).filter(Users.id &gt; 0).update(&#123;&quot;name&quot; : &quot;lqz&quot;&#125;)#类似于django的F查询session.query(Users).filter(Users.id &gt; 0).update(&#123;Users.name: Users.name + &quot;099&quot;&#125;, synchronize_session=False)session.query(Users).filter(Users.id &gt; 0).update(&#123;&quot;age&quot;: Users.age + 1&#125;, synchronize_session=&quot;evaluate&quot;)session.commit()&quot;&quot;&quot;# ################ 查询 ################&quot;&quot;&quot;r1 = session.query(Users).all()#只取age列，把name重命名为xxr2 = session.query(Users.name.label(&#x27;xx&#x27;), Users.age).all()#filter传的是表达式，filter_by传的是参数r3 = session.query(Users).filter(Users.name == &quot;lqz&quot;).all()r4 = session.query(Users).filter_by(name=&#x27;lqz&#x27;).all()r5 = session.query(Users).filter_by(name=&#x27;lqz&#x27;).first()#:value 和:name 相当于占位符，用params传参数r6 = session.query(Users).filter(text(&quot;id&lt;:value and name=:name&quot;)).params(value=224, name=&#x27;fred&#x27;).order_by(Users.id).all()#自定义查询sqlr7 = session.query(Users).from_statement(text(&quot;SELECT * FROM users where name=:name&quot;)).params(name=&#x27;ed&#x27;).all()&quot;&quot;&quot;#增，删，改都要commit()session.close() 8.常用操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 条件ret = session.query(Users).filter_by(name=&#x27;lqz&#x27;).all()#表达式，and条件连接ret = session.query(Users).filter(Users.id &gt; 1, Users.name == &#x27;eric&#x27;).all()ret = session.query(Users).filter(Users.id.between(1, 3), Users.name == &#x27;eric&#x27;).all()#注意下划线ret = session.query(Users).filter(Users.id.in_([1,3,4])).all()#~非，除。。外ret = session.query(Users).filter(~Users.id.in_([1,3,4])).all()#二次筛选ret = session.query(Users).filter(Users.id.in_(session.query(Users.id).filter_by(name=&#x27;eric&#x27;))).all()from sqlalchemy import and_, or_#or_包裹的都是or条件，and_包裹的都是and条件ret = session.query(Users).filter(and_(Users.id &gt; 3, Users.name == &#x27;eric&#x27;)).all()ret = session.query(Users).filter(or_(Users.id &lt; 2, Users.name == &#x27;eric&#x27;)).all()ret = session.query(Users).filter( or_( Users.id &lt; 2, and_(Users.name == &#x27;eric&#x27;, Users.id &gt; 3), Users.extra != &quot;&quot; )).all()# 通配符，以e开头，不以e开头ret = session.query(Users).filter(Users.name.like(&#x27;e%&#x27;)).all()ret = session.query(Users).filter(~Users.name.like(&#x27;e%&#x27;)).all()# 限制，用于分页，区间ret = session.query(Users)[1:2]# 排序，根据name降序排列（从大到小）ret = session.query(Users).order_by(Users.name.desc()).all()#第一个条件重复后，再按第二个条件升序排ret = session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()# 分组from sqlalchemy.sql import funcret = session.query(Users).group_by(Users.extra).all()#分组之后取最大id，id之和，最小idret = session.query( func.max(Users.id), func.sum(Users.id), func.min(Users.id)).group_by(Users.name).all()#haviing筛选ret = session.query( func.max(Users.id), func.sum(Users.id), func.min(Users.id)).group_by(Users.name).having(func.min(Users.id) &gt;2).all()# 连表（默认用forinkey关联）ret = session.query(Users, Favor).filter(Users.id == Favor.nid).all()#join表，默认是inner joinret = session.query(Person).join(Favor).all()#isouter=True 外连，表示Person left join Favor，没有右连接，反过来即可ret = session.query(Person).join(Favor, isouter=True).all()#打印原生sqlaa=session.query(Person).join(Favor, isouter=True)print(aa)# 自己指定on条件（连表条件）,第二个参数，支持on多个条件，用and_,同上ret = session.query(Person).join(Favor,Person.id==Favor.id, isouter=True).all()# 组合（了解）UNION 操作符用于合并两个或多个 SELECT 语句的结果集#union和union all的区别？q1 = session.query(Users.name).filter(Users.id &gt; 2)q2 = session.query(Favor.caption).filter(Favor.nid &lt; 2)ret = q1.union(q2).all()q1 = session.query(Users.name).filter(Users.id &gt; 2)q2 = session.query(Favor.caption).filter(Favor.nid &lt; 2)ret = q1.union_all(q2).all() 9.执行原生sql 1234567891011121314151617181920212223242526import timeimport threadingfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Indexfrom sqlalchemy.orm import sessionmaker, relationshipfrom sqlalchemy import create_enginefrom sqlalchemy.sql import textfrom sqlalchemy.engine.result import ResultProxyfrom db import Users, Hostsengine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6&quot;, max_overflow=0, pool_size=5)Session = sessionmaker(bind=engine)session = Session()# 查询# cursor = session.execute(&#x27;select * from users&#x27;)# result = cursor.fetchall()# 添加cursor = session.execute(&#x27;insert into users(name) values(:value)&#x27;,params=&#123;&quot;value&quot;:&#x27;lqz&#x27;&#125;)session.commit()print(cursor.lastrowid)session.close() 10.一对多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import timeimport threadingfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Indexfrom sqlalchemy.orm import sessionmaker, relationshipfrom sqlalchemy import create_enginefrom sqlalchemy.sql import textfrom sqlalchemy.engine.result import ResultProxyfrom db import Users, Hosts, Hobby, Personengine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6?charset=utf8&quot;, max_overflow=0, pool_size=5)Session = sessionmaker(bind=engine)session = Session()# 添加&quot;&quot;&quot;session.add_all([ Hobby(caption=&#x27;乒乓球&#x27;), Hobby(caption=&#x27;羽毛球&#x27;), Person(name=&#x27;张三&#x27;, hobby_id=3), Person(name=&#x27;李四&#x27;, hobby_id=4),])person = Person(name=&#x27;张九&#x27;, hobby=Hobby(caption=&#x27;姑娘&#x27;))session.add(person)#添加二hb = Hobby(caption=&#x27;人妖&#x27;)hb.pers = [Person(name=&#x27;文飞&#x27;), Person(name=&#x27;博雅&#x27;)]session.add(hb)session.commit()&quot;&quot;&quot;# 使用relationship正向查询&quot;&quot;&quot;v = session.query(Person).first()print(v.name)print(v.hobby.caption)&quot;&quot;&quot;# 使用relationship反向查询&quot;&quot;&quot;v = session.query(Hobby).first()print(v.caption)print(v.pers)&quot;&quot;&quot;#方式一，自己链表# person_list=session.query(models.Person.name,models.Hobby.caption).join(models.Hobby,isouter=True).all()person_list=session.query(models.Person,models.Hobby).join(models.Hobby,isouter=True).all()for row in person_list: # print(row.name,row.caption) print(row[0].name,row[1].caption)#方式二：通过relationshipperson_list=session.query(models.Person).all()for row in person_list: print(row.name,row.hobby.caption)#查询喜欢姑娘的所有人obj=session.query(models.Hobby).filter(models.Hobby.id==1).first()persons=obj.persprint(persons)session.close() 11.多对多 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import timeimport threadingfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Indexfrom sqlalchemy.orm import sessionmaker, relationshipfrom sqlalchemy import create_enginefrom sqlalchemy.sql import textfrom sqlalchemy.engine.result import ResultProxyfrom db import Users, Hosts, Hobby, Person, Group, Server, Server2Groupengine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6?charset=utf8&quot;, max_overflow=0, pool_size=5)Session = sessionmaker(bind=engine)session = Session()# 添加&quot;&quot;&quot;session.add_all([ Server(hostname=&#x27;c1.com&#x27;), Server(hostname=&#x27;c2.com&#x27;), Group(name=&#x27;A组&#x27;), Group(name=&#x27;B组&#x27;),])session.commit()s2g = Server2Group(server_id=1, group_id=1)session.add(s2g)session.commit()gp = Group(name=&#x27;C组&#x27;)gp.servers = [Server(hostname=&#x27;c3.com&#x27;),Server(hostname=&#x27;c4.com&#x27;)]session.add(gp)session.commit()ser = Server(hostname=&#x27;c6.com&#x27;)ser.groups = [Group(name=&#x27;F组&#x27;),Group(name=&#x27;G组&#x27;)]session.add(ser)session.commit()&quot;&quot;&quot;# 使用relationship正向查询&quot;&quot;&quot;v = session.query(Group).first()print(v.name)print(v.servers)&quot;&quot;&quot;# 使用relationship反向查询&quot;&quot;&quot;v = session.query(Server).first()print(v.hostname)print(v.groups)&quot;&quot;&quot;session.close() 12.其它 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import timeimport threadingfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Indexfrom sqlalchemy.orm import sessionmaker, relationshipfrom sqlalchemy import create_enginefrom sqlalchemy.sql import text, funcfrom sqlalchemy.engine.result import ResultProxyfrom db import Users, Hosts, Hobby, Person, Group, Server, Server2Groupengine = create_engine(&quot;mysql+pymysql://root:123@127.0.0.1:3306/s6?charset=utf8&quot;, max_overflow=0, pool_size=5)Session = sessionmaker(bind=engine)session = Session()# 关联子查询:correlate(Group)表示跟Group表做关联，as_scalar相当于对该sql加括号，用于放在后面当子查询subqry = session.query(func.count(Server.id).label(&quot;sid&quot;)).filter(Server.id == Group.id).correlate(Group).as_scalar()result = session.query(Group.name, subqry)&quot;&quot;&quot;SELECT `group`.name AS group_name, (SELECT count(server.id) AS sid FROM server WHERE server.id = `group`.id) AS anon_1 FROM `group`&quot;&quot;&quot;&#x27;&#x27;&#x27;select * from tb where id in [select id from xxx];select id, name, #必须保证此次查询只有一个值 (select max(id) from xxx) as midfrom tb例如，第三个字段只能有一个值id name mid1 lqz 1，2 不合理2 egon 2&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;成绩表：id sid cid score1 1 物理 99 2 1 化学 883 2 物理 95学生表：id name 每个学生总分数1 xx 882 yy 77select id，name,(select avr(score) from 成绩表 where 成绩表.sid=学生表.id) as xfrom 学生表subqry = session.query(func.count(成绩表.scort).label(&quot;sc&quot;)).filter(学生表.id == 成绩表.sid).correlate(学生表).as_scalar()result = session.query(学生表.name, subqry)&#x27;&#x27;&#x27;# 原生SQL&quot;&quot;&quot;# 查询cursor = session.execute(&#x27;select * from users&#x27;)result = cursor.fetchall()# 添加cursor = session.execute(&#x27;insert into users(name) values(:value)&#x27;,params=&#123;&quot;value&quot;:&#x27;wupeiqi&#x27;&#125;)session.commit()print(cursor.lastrowid)&quot;&quot;&quot;session.close() 13.Flask-SQLAlchemy flask和SQLAchemy的管理者，通过他把他们做连接 123456db = SQLAlchemy() - 包含配置 - 包含ORM基类 - 包含create_all - engine - 创建连接 离线脚本，创建表 详见代码 flask-migrate python3 manage.py db init 初始化：只执行一次 python3 manage.py db migrate 等同于 makemigartions python3 manage.py db upgrade 等同于migrate","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"9-1 Flask","slug":"flask/9-1 总结_flask","date":"2021-01-18T11:39:27.130Z","updated":"2021-01-18T14:10:36.569Z","comments":true,"path":"2021/01/18/flask/9-1 总结_flask/","link":"","permalink":"http://example.com/2021/01/18/flask/9-1%20%E6%80%BB%E7%BB%93_flask/","excerpt":"","text":"0.Flask简介 Flask是一个基于Python开发并且依赖jinja2模板和Werkzeug WSGI服务的一个微型框架，对于Werkzeug本质是Socket服务端，其用于接收http请求并对请求进行预处理，然后触发Flask框架，开发人员基于Flask框架提供的功能对请求进行相应的处理，并返回给用户，如果要返回给用户复杂的内容时，需要借助jinja2模板来实现对模板的处理，即：将模板和数据进行渲染，将渲染后的字符串返回给用户浏览器。 “微”(micro) 并不表示你需要把整个 Web 应用塞进单个 Python 文件（虽然确实可以 ），也不意味着 Flask 在功能上有所欠缺。微框架中的“微”意味着 Flask 旨在保持核心简单而易于扩展。Flask 不会替你做出太多决策——比如使用何种数据库。而那些 Flask 所选择的——比如使用何种模板引擎——则很容易替换。除此之外的一切都由可由你掌握。如此，Flask 可以与您珠联璧合。 默认情况下，Flask 不包含数据库抽象层、表单验证，或是其它任何已有多种库可以胜任的功能。然而，Flask 支持用扩展来给应用添加这些功能，如同是 Flask 本身实现的一样。众多的扩展提供了数据库集成、表单验证、上传处理、各种各样的开放认证技术等功能。Flask 也许是“微小”的，但它已准备好在需求繁杂的生产环境中投入使用 wsgiref 最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。 如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。 正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口协议来实现这样的服务器软件，让我们专心用Python编写Web业务。这个接口就是WSGI：Web Server Gateway Interface。而wsgiref模块就是python基于wsgi协议开发的服务模块 12345678910111213141516171819202122from wsgiref.simple_server import make_serverdef mya(environ, start_response): print(environ) start_response(&#x27;200 OK&#x27;, [(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;)]) if environ.get(&#x27;PATH_INFO&#x27;) == &#x27;/index&#x27;: with open(&#x27;index.html&#x27;,&#x27;rb&#x27;) as f: data=f.read() elif environ.get(&#x27;PATH_INFO&#x27;) == &#x27;/login&#x27;: with open(&#x27;login.html&#x27;, &#x27;rb&#x27;) as f: data = f.read() else: data=b&#x27;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#x27; return [data]if __name__ == &#x27;__main__&#x27;: myserver = make_server(&#x27;&#x27;, 8011, mya) print(&#x27;监听8010&#x27;) myserver.serve_forever()wsgiref简单应用 1.安装 1pip3 install flask 2.werkzeug简介 Werkzeug是一个WSGI工具包，他可以作为一个Web框架的底层库。这里稍微说一下， werkzeug 不是一个web服务器，也不是一个web框架，而是一个工具包，官方的介绍说是一个 WSGI 工具包，它可以作为一个 Web 框架的底层库，因为它封装好了很多 Web 框架的东西，例如 Request，Response 等等 代码示例： 123456789from werkzeug.wrappers import Request, Response@Request.applicationdef hello(request): return Response(&#x27;Hello World!&#x27;)if __name__ == &#x27;__main__&#x27;: from werkzeug.serving import run_simple run_simple(&#x27;localhost&#x27;, 4000, hello) 3.flask快速使用 12345678910from flask import Flask# 实例化产生一个Flask对象app = Flask(__name__)# 将 &#x27;/&#x27;和视图函数hello_workd的对应关系添加到路由中@app.route(&#x27;/&#x27;) # 1. v=app.route(&#x27;/&#x27;) 2. v(hello_world)def hello_world(): return &#x27;Hello World!&#x27;if __name__ == &#x27;__main__&#x27;: app.run() # 最终调用了run_simple() 案例：登录，显示用户信息 main.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from flask import Flask,render_template,request,redirect,session,url_forapp = Flask(__name__)app.debug = Trueapp.secret_key = &#x27;sdfsdfsdfsdf&#x27;USERS = &#123; 1:&#123;&#x27;name&#x27;:&#x27;张三&#x27;,&#x27;age&#x27;:18,&#x27;gender&#x27;:&#x27;男&#x27;,&#x27;text&#x27;:&quot;道路千万条&quot;&#125;, 2:&#123;&#x27;name&#x27;:&#x27;李四&#x27;,&#x27;age&#x27;:28,&#x27;gender&#x27;:&#x27;男&#x27;,&#x27;text&#x27;:&quot;安全第一条&quot;&#125;, 3:&#123;&#x27;name&#x27;:&#x27;王五&#x27;,&#x27;age&#x27;:18,&#x27;gender&#x27;:&#x27;女&#x27;,&#x27;text&#x27;:&quot;行车不规范&quot;&#125;,&#125;@app.route(&#x27;/detail/&lt;int:nid&gt;&#x27;,methods=[&#x27;GET&#x27;])def detail(nid): user = session.get(&#x27;user_info&#x27;) if not user: return redirect(&#x27;/login&#x27;) info = USERS.get(nid) return render_template(&#x27;detail.html&#x27;,info=info)@app.route(&#x27;/index&#x27;,methods=[&#x27;GET&#x27;])def index(): user = session.get(&#x27;user_info&#x27;) if not user: # return redirect(&#x27;/login&#x27;) url = url_for(&#x27;l1&#x27;) return redirect(url) return render_template(&#x27;index.html&#x27;,user_dict=USERS)@app.route(&#x27;/login&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;],endpoint=&#x27;l1&#x27;)def login(): if request.method == &quot;GET&quot;: return render_template(&#x27;login.html&#x27;) else: # request.query_string user = request.form.get(&#x27;user&#x27;) pwd = request.form.get(&#x27;pwd&#x27;) if user == &#x27;cxw&#x27; and pwd == &#x27;123&#x27;: session[&#x27;user_info&#x27;] = user return redirect(&#x27;http://www.baidu.com&#x27;) return render_template(&#x27;login.html&#x27;,error=&#x27;用户名或密码错误&#x27;)if __name__ == &#x27;__main__&#x27;: app.run() detail.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;详细信息 &#123;&#123;info.name&#125;&#125;&lt;/h1&gt; &lt;div&gt; &#123;&#123;info.text&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; index.html 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户列表&lt;/h1&gt; &lt;table&gt; &#123;% for k,v in user_dict.items() %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;k&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;v.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;v[&#x27;name&#x27;]&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;v.get(&#x27;name&#x27;)&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/detail/&#123;&#123;k&#125;&#125;&quot;&gt;查看详细&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; login.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户登录&lt;/h1&gt; &lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;pwd&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&#123;&#123;error&#125;&#125; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 作业：登录认证装饰器 -多个装饰器执行顺序 -反向查找的名称（endpoint），不允许重复 4.配置文件 flask中的配置文件是一个flask.config.Config对象（继承字典）,默认配置为： 123456789101112131415161718192021222324252627282930&#123; &#x27;DEBUG&#x27;: False # get_debug_flag(default=False), 是否开启Debug模式 &#x27;TESTING&#x27;: False, # 是否开启测试模式 &#x27;PROPAGATE_EXCEPTIONS&#x27;: None, &#x27;PRESERVE_CONTEXT_ON_EXCEPTION&#x27;: None, &#x27;SECRET_KEY&#x27;: None, &#x27;PERMANENT_SESSION_LIFETIME&#x27;: timedelta(days=31), &#x27;USE_X_SENDFILE&#x27;: False, &#x27;LOGGER_NAME&#x27;: None, &#x27;LOGGER_HANDLER_POLICY&#x27;: &#x27;always&#x27;, &#x27;SERVER_NAME&#x27;: None, &#x27;APPLICATION_ROOT&#x27;: None, &#x27;SESSION_COOKIE_NAME&#x27;: &#x27;session&#x27;, &#x27;SESSION_COOKIE_DOMAIN&#x27;: None, &#x27;SESSION_COOKIE_PATH&#x27;: None, &#x27;SESSION_COOKIE_HTTPONLY&#x27;: True, &#x27;SESSION_COOKIE_SECURE&#x27;: False, &#x27;SESSION_REFRESH_EACH_REQUEST&#x27;: True, &#x27;MAX_CONTENT_LENGTH&#x27;: None, &#x27;SEND_FILE_MAX_AGE_DEFAULT&#x27;: timedelta(hours=12), &#x27;TRAP_BAD_REQUEST_ERRORS&#x27;: False, &#x27;TRAP_HTTP_EXCEPTIONS&#x27;: False, &#x27;EXPLAIN_TEMPLATE_LOADING&#x27;: False, &#x27;PREFERRED_URL_SCHEME&#x27;: &#x27;http&#x27;, &#x27;JSON_AS_ASCII&#x27;: True, &#x27;JSON_SORT_KEYS&#x27;: True, &#x27;JSONIFY_PRETTYPRINT_REGULAR&#x27;: True, &#x27;JSONIFY_MIMETYPE&#x27;: &#x27;application/json&#x27;, &#x27;TEMPLATES_AUTO_RELOAD&#x27;: None,&#125; 方式一 12app.config[&#x27;DEBUG&#x27;] = True PS： 由于Config对象本质上是字典，所以还可以使用app.config.update(...) 方式二 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#通过py文件配置app.config.from_pyfile(&quot;python文件名称&quot;)如：settings.pyDEBUG = Trueapp.config.from_pyfile(&quot;settings.py&quot;)#通过环境变量配置app.config.from_envvar(&quot;环境变量名称&quot;)#app.config.from_pyfile(os.environ[&#x27;YOURAPPLICATION_SETTINGS&#x27;])环境变量的值为python文件名称名称，内部调用from_pyfile方法app.config.from_json(&quot;json文件名称&quot;)JSON文件名称，必须是json格式，因为内部会执行json.loadsapp.config.from_mapping(&#123;&#x27;DEBUG&#x27;: True&#125;)字典格式app.config.from_object(&quot;python类或类的路径&quot;)app.config.from_object(&#x27;pro_flask.settings.TestingConfig&#x27;)settings.pyclass Config(object): DEBUG = False TESTING = False DATABASE_URI = &#x27;sqlite://:memory:&#x27;class ProductionConfig(Config): DATABASE_URI = &#x27;mysql://user@localhost/foo&#x27;class DevelopmentConfig(Config): DEBUG = Trueclass TestingConfig(Config): TESTING = TruePS: 从sys.path中已经存在路径开始写PS: settings.py文件默认路径要放在程序root_path目录，如果instance_relative_config为True，则就是instance_path目录（Flask对象init方法的参数） 典型写法 1@app.route(&#x27;/detail/&lt;int:nid&gt;&#x27;,methods=[&#x27;GET&#x27;],endpoint=&#x27;detail&#x27;) 默认转换器 123456789DEFAULT_CONVERTERS = &#123; &#x27;default&#x27;: UnicodeConverter, &#x27;string&#x27;: UnicodeConverter, &#x27;any&#x27;: AnyConverter, &#x27;path&#x27;: PathConverter, &#x27;int&#x27;: IntegerConverter, &#x27;float&#x27;: FloatConverter, &#x27;uuid&#x27;: UUIDConverter,&#125; 路由系统本质 123456789101112131415161718192021&quot;&quot;&quot;1. decorator = app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;],endpoint=&#x27;n1&#x27;) def route(self, rule, **options): # app对象 # rule= / # options = &#123;methods=[&#x27;GET&#x27;,&#x27;POST&#x27;],endpoint=&#x27;n1&#x27;&#125; def decorator(f): endpoint = options.pop(&#x27;endpoint&#x27;, None) self.add_url_rule(rule, endpoint, f, **options) return f return decorator2. @decorator decorator(index)&quot;&quot;&quot;#同理def login(): return &#x27;登录&#x27;app.add_url_rule(&#x27;/login&#x27;, &#x27;n2&#x27;, login, methods=[&#x27;GET&#x27;,&quot;POST&quot;])#与django路由类似#django与flask路由：flask路由基于装饰器，本质是基于：add_url_rule#add_url_rule 源码中，endpoint如果为空，endpoint = _endpoint_from_view_func(view_func)，最终取view_func.__name__（函数名） CBV(源码分析) 123456789101112131415161718192021222324252627282930def auth(func): def inner(*args, **kwargs): print(&#x27;before&#x27;) result = func(*args, **kwargs) print(&#x27;after&#x27;) return result return innerclass IndexView(views.View): methods = [&#x27;GET&#x27;] decorators = [auth, ] def dispatch_request(self): print(&#x27;Index&#x27;) return &#x27;Index!&#x27;app.add_url_rule(&#x27;/index&#x27;, view_func=IndexView.as_view(name=&#x27;index&#x27;)) # name=endpoint#或者，通常用此方式class IndexView(views.MethodView): methods = [&#x27;GET&#x27;] decorators = [auth, ] def get(self): return &#x27;Index.GET&#x27; def post(self): return &#x27;Index.POST&#x27; app.add_url_rule(&#x27;/index&#x27;, view_func=IndexView.as_view(name=&#x27;index&#x27;)) # name=endpoint app.add_url_rule参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@app.route和app.add_url_rule参数: rule, # URL规则view_func, # 视图函数名称defaults = None, # 默认值, 当URL中无参数，函数需要参数时，使用defaults = &#123;&#x27;k&#x27;: &#x27;v&#x27;&#125;为函数提供参数endpoint = None, # 名称，用于反向生成URL，即： url_for(&#x27;名称&#x27;)methods = None, # 允许的请求方式，如：[&quot;GET&quot;, &quot;POST&quot;]#对URL最后的 / 符号是否严格要求strict_slashes = None &#x27;&#x27;&#x27; @app.route(&#x27;/index&#x27;, strict_slashes=False) #访问http://www.xx.com/index/ 或http://www.xx.com/index均可 @app.route(&#x27;/index&#x27;, strict_slashes=True) #仅访问http://www.xx.com/index &#x27;&#x27;&#x27;#重定向到指定地址redirect_to = None, &#x27;&#x27;&#x27; @app.route(&#x27;/index/&lt;int:nid&gt;&#x27;, redirect_to=&#x27;/home/&lt;nid&gt;&#x27;) &#x27;&#x27;&#x27;#子域名访问subdomain = None, &#x27;&#x27;&#x27; #C:\\Windows\\System32\\drivers\\etc\\hosts 127.0.0.1 www.liuqingzheng.com 127.0.0.1 admin.liuqingzheng.com 127.0.0.1 buy.liuqingzheng.com from flask import Flask, views, url_for app = Flask(import_name=__name__) app.config[&#x27;SERVER_NAME&#x27;] = &#x27;liuqingzheng.com:5000&#x27; @app.route(&quot;/&quot;, subdomain=&quot;admin&quot;) def static_index(): &quot;&quot;&quot;Flask supports static subdomains This is available at static.your-domain.tld&quot;&quot;&quot; return &quot;static.your-domain.tld&quot; #可以传入任意的字符串，如传入的字符串为aa，显示为 aa.liuqingzheng.com @app.route(&quot;/dynamic&quot;, subdomain=&quot;&lt;username&gt;&quot;) def username_index(username): &quot;&quot;&quot;Dynamic subdomains are also supported Try going to user1.your-domain.tld/dynamic&quot;&quot;&quot; return username + &quot;.your-domain.tld&quot; if __name__ == &#x27;__main__&#x27;: app.run() 访问： http://www.liuqingzheng.com:5000/dynamic http://admin.liuqingzheng.com:5000/dynamic http://buy.liuqingzheng.com:5000/dynamic &#x27;&#x27;&#x27; 支持正则 12345678910111213141516171819202122232425262728293031323334353637#1 写类，继承BaseConverter#2 注册：app.url_map.converters[&#x27;regex&#x27;] = RegexConverter#3 使用：@app.route(&#x27;/index/&lt;regex(&quot;\\d+&quot;):nid&gt;&#x27;) 正则表达式会当作第二个参数传递到类中from flask import Flask, views, url_forfrom werkzeug.routing import BaseConverterapp = Flask(import_name=__name__)class RegexConverter(BaseConverter): &quot;&quot;&quot; 自定义URL匹配正则表达式 &quot;&quot;&quot; def __init__(self, map, regex): super(RegexConverter, self).__init__(map) self.regex = regex def to_python(self, value): &quot;&quot;&quot; 路由匹配时，匹配成功后传递给视图函数中参数的值 &quot;&quot;&quot; return int(value) def to_url(self, value): &quot;&quot;&quot; 使用url_for反向生成URL时，传递的参数经过该方法处理，返回的值用于生成URL中的参数 &quot;&quot;&quot; val = super(RegexConverter, self).to_url(value) return val# 添加到flask中app.url_map.converters[&#x27;regex&#x27;] = RegexConverter@app.route(&#x27;/index/&lt;regex(&quot;\\d+&quot;):nid&gt;&#x27;)def index(nid): print(url_for(&#x27;index&#x27;, nid=&#x27;888&#x27;)) return &#x27;Index&#x27;if __name__ == &#x27;__main__&#x27;: app.run() 6.模版 6.1渲染变量 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户列表&lt;/h1&gt; &lt;table&gt; &#123;% for k,v in user_dict.items() %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;k&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;v.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;v[&#x27;name&#x27;]&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;v.get(&#x27;name&#x27;)&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/detail/&#123;&#123;k&#125;&#125;&quot;&gt;查看详细&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 6.2变量的循环 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户列表&lt;/h1&gt; &lt;table&gt; &#123;% for k,v in user_dict.items() %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;k&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;v.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;v[&#x27;name&#x27;]&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;v.get(&#x27;name&#x27;)&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/detail/&#123;&#123;k&#125;&#125;&quot;&gt;查看详细&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 6.3逻辑判断 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;用户列表&lt;/h1&gt; &lt;table&gt; &#123;% if name %&#125; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt; &#123;% else %&#125; &lt;h1&gt;Hello World!&lt;/h1&gt; &#123;% endif %&#125; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 比django中多可以加括号，执行函数，传参数 1234567891011from flask import Flask,render_template,Markup,jsonify,make_responseapp = Flask(__name__)def func1(arg): return Markup(&quot;&lt;input type=&#x27;text&#x27; value=&#x27;%s&#x27; /&gt;&quot; %(arg,))@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index.html&#x27;,ff = func1)if __name__ == &#x27;__main__&#x27;: app.run() index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;&#123;ff(&#x27;六五&#x27;)&#125;&#125; &#123;&#123;ff(&#x27;六五&#x27;)|safe&#125;&#125;&lt;/body&gt;&lt;/html&gt; 注意： 1.Markup等价django的mark_safe , 2.extends,include一模一样 7.请求响应 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from flask import Flaskfrom flask import requestfrom flask import render_templatefrom flask import redirectfrom flask import make_responseapp = Flask(__name__)@app.route(&#x27;/login.html&#x27;, methods=[&#x27;GET&#x27;, &quot;POST&quot;])def login(): # 请求相关信息 # request.method 提交的方法 # request.args get请求提及的数据 # request.form post请求提交的数据 # request.values post和get提交的数据总和 # request.cookies 客户端所带的cookie # request.headers 请求头 # request.path 不带域名，请求路径 # request.full_path 不带域名，带参数的请求路径 # request.script_root # request.url 带域名带参数的请求路径 # request.base_url 带域名请求路径 # request.url_root 域名 # request.host_url 域名 # request.host 127.0.0.1:500 # request.files # obj = request.files[&#x27;the_file_name&#x27;] # obj.save(&#x27;/var/www/uploads/&#x27; + secure_filename(f.filename)) # 响应相关信息 # return &quot;字符串&quot; # return render_template(&#x27;html模板路径&#x27;,**&#123;&#125;) # return redirect(&#x27;/index.html&#x27;) #return jsonify(&#123;&#x27;k1&#x27;:&#x27;v1&#x27;&#125;) # response = make_response(render_template(&#x27;index.html&#x27;)) # response是flask.wrappers.Response类型 # response.delete_cookie(&#x27;key&#x27;) # response.set_cookie(&#x27;key&#x27;, &#x27;value&#x27;) # response.headers[&#x27;X-Something&#x27;] = &#x27;A value&#x27; # return response return &quot;内容&quot;if __name__ == &#x27;__main__&#x27;: app.run() 8.session 123cookie:存放在客户端的键值对session：存放在客户端的键值对token:存放在客户端，通过算法来校验 在使用session之前必须现在设置一下密钥 1app.secret_key=&quot;asdas&quot; #值随便 除请求对象之外，还有一个 session 对象。它允许你在不同请求间存储特定用户的信息。它是在 Cookies 的基础上实现的，并且对 Cookies 进行密钥签名要使用会话，你需要设置一个密钥。 (app.session_interface对象) 1234567设置：session[&#x27;username&#x27;] ＝ &#x27;xxx&#x27;#在django中发什么三件事，1，生成一个随机的字符串 2 往数据库存 3 写入cookie返回浏览器#在flask中他没有数据库，但session是怎样实现的？ # 生成一个密钥写入这个cookie,然后下次请求的时候，通过这个cookie解密，然后赋值给session #我们通过app.session_interface来查看 删除：session.pop(&#x27;username&#x27;, None) app.session_interface中save_session的参数（设置cookie的参数） 12345678key, # 键value=&#x27;&#x27;, # 值max_age=None, # 超时时间 cookie需要延续的时间（以秒为单位）如果参数是\\ None`` ，这个cookie会延续到浏览器关闭为止expires=None, # 超时时间(IE requires expires, so set it if hasn&#x27;t been already.)path=&#x27;/&#x27;, # Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问，浏览器只会把cookie回传给带有该路径的页面，这样可以避免将cookie传给站点中的其他的应用。domain=None, # Cookie生效的域名 你可用这个参数来构造一个跨站cookie。如， domain=&quot;.example.com&quot;所构造的cookie对下面这些站点都是可读的：www.example.com 、 www2.example.com 和an.other.sub.domain.example.com 。如果该参数设置为 None ，cookie只能由设置它的站点读取secure=False, # 浏览器将通过HTTPS来回传cookiehttponly=False # 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） session源码的执行流程 1234-save_seesion -响应的时候，把session中的值加密序列化放大到了cookie中，返回到浏览器中-open_session -请求来了，从cookie中取出值，反解，生成session对象，以后再视图函数中直接用sessoin就可以了。 9.闪现（message） 1234-设置:flash(&#x27;aaa&#x27;)-取值：get_flashed_message()--假设在a页面操作出错，跳转到b页面，在b页面显示a页面的错误信息 示例： 123456789101112131415161718192021222324252627282930313233from flask import Flask,flash,get_flashed_messages,request,redirectapp = Flask(__name__)app.secret_key = &#x27;asdfasdf&#x27;@app.route(&#x27;/index&#x27;)def index(): # 从某个地方获取设置过的所有值，并清除。 val = request.args.get(&#x27;v&#x27;) if val == &#x27;oldboy&#x27;: return &#x27;Hello World!&#x27; flash(&#x27;超时错误&#x27;,category=&quot;x1&quot;) return &quot;ssdsdsdfsd&quot; # return redirect(&#x27;/error&#x27;)@app.route(&#x27;/error&#x27;)def error(): &quot;&quot;&quot; 展示错误信息 :return: 如果get_flashed_messages(with_category=True) &quot;&quot;&quot; data = get_flashed_messages(category_filter=[&#x27;x1&#x27;]) if data: msg = data[0] else: msg = &quot;...&quot; return &quot;错误信息：%s&quot; %(msg,)if __name__ == &#x27;__main__&#x27;: app.run() 10.请求扩展 1 before_request 类比django中间件中的process_request，在请求收到之前绑定一个函数做一些事情 123456789#基于它做用户登录认证@app.before_requestdef process_request(*args,**kwargs): if request.path == &#x27;/login&#x27;: return None user = session.get(&#x27;user_info&#x27;) if user: return None return redirect(&#x27;/login&#x27;) 2 after_request 类比django中间件中的process_response，每一个请求之后绑定一个函数，如果请求没有异常 1234@app.after_requestdef process_response1(response): print(&#x27;process_response1 走了&#x27;) return response 3 before_first_request 第一次请求时,跟浏览器无关 123@app.before_first_requestdef first(): pass 4 teardown_request 每一个请求之后绑定一个函数，即使遇到了异常 123@app.teardown_request def ter(e): pass 5 errorhandler 路径不存在时404，服务器内部错误500 123@app.errorhandler(404)def error_404(arg): return &quot;404错误了&quot; 6 template_global 标签 1234@app.template_global()def sb(a1, a2): return a1 + a2#&#123;&#123;sb(1,2)&#125;&#125; 7 template_filter 过滤器 1234@app.template_filter()def db(a1, a2, a3): return a1 + a2 + a3#&#123;&#123; 1|db(2,3)&#125;&#125; 总结： 1 重点掌握before_request和after_request， 2 注意有多个的情况，执行顺序 3 before_request请求拦截后（也就是有return值），response所有都执行 11 中间件（了解） 123456789101112131415161718192021222324252627from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &#x27;Hello World!&#x27;# 模拟中间件class Md(object): def __init__(self,old_wsgi_app): self.old_wsgi_app = old_wsgi_app def __call__(self, environ, start_response): print(&#x27;开始之前&#x27;) ret = self.old_wsgi_app(environ, start_response) print(&#x27;结束之后&#x27;) return retif __name__ == &#x27;__main__&#x27;: #1我们发现当执行app.run方法的时候，最终执行run_simple，最后执行app(),也就是在执行app.__call__方法 #2 在__call__里面，执行的是self.wsgi_app().那我们希望在执行他本身的wsgi之前做点事情。 #3 所以我们先用Md类中__init__，保存之前的wsgi,然后我们用将app.wsgi转化成Md的对象。 #4 那执行新的的app.wsgi_app，就是执行Md的__call__方法。 #把原来的wsgi_app替换为自定义的， app.wsgi_app = Md(app.wsgi_app) app.run() 请求所有的流程 12345678910111213141516171819ctx = self.request_context(environ) error = None try: try: ctx.push() #根据路径去执行视图函数，视图类 response = self.full_dispatch_request() except Exception as e: error = e response = self.handle_exception(e) except: # noqa: B001 error = sys.exc_info()[1] raise return response(environ, start_response) finally: #不管出不出异常，都会走这里 if self.should_ignore_error(error): error = None ctx.auto_pop(error) 12.蓝图 对程序进行目录结构划分 不使用蓝图，自己分文件 目录结构： 123456-templates-views -__init__.py -user.py -order.py-app.py app.py 123from views import appif __name__ == &#x27;__main__&#x27;: app.run() init.py 123456from flask import Flask,requestapp = Flask(__name__)#不导入这个不行from . import accountfrom . import orderfrom . import user user.py 1234from . import app@app.route(&#x27;/user&#x27;)def user(): return &#x27;user&#x27; order.py 1234from . import app@app.route(&#x27;/order&#x27;)def order(): return &#x27;order&#x27; 使用蓝图之中小型系统 详见代码：pro_flask_简单应用程序目录示例.zip 目录结构： 12345678910-flask_pro -flask_test -__init__.py -static -templates -views -order.py -user.py -manage.py _init.py 123456from flask import Flaskapp=Flask(__name__)from flask_test.views import userfrom flask_test.views import orderapp.register_blueprint(user.us)app.register_blueprint(order.ord) manage.py 123from flask_test import appif __name__ == &#x27;__main__&#x27;: app.run(port=8008) user.py 123456from flask import Blueprintus=Blueprint(&#x27;user&#x27;,__name__)@us.route(&#x27;/login&#x27;)def login(): return &#x27;login&#x27; order.py 123456from flask import Blueprintord=Blueprint(&#x27;order&#x27;,__name__)@ord.route(&#x27;/test&#x27;)def test(): return &#x27;order test&#x27; 使用蓝图之大型系统 详见代码：pro_flask_大型应用目录示例.zip 总结： 1 xxx = Blueprint(‘account’, name,url_prefix=’/xxx’) ：蓝图URL前缀，表示url的前缀，在该蓝图下所有url都加前缀 2 xxx = Blueprint(‘account’, name,url_prefix=’/xxx’,template_folder=‘tpls’)：给当前蓝图单独使用templates，向上查找，当前找不到，会找总templates 3 蓝图的befort_request，对当前蓝图有效 4 大型项目，可以模拟出类似于django中app的概念 13.请求上下文源码分析 12345678910111213141516第一阶段：将ctx(request,session)放到Local对象上 第二阶段：视图函数导入：request/session request.method -LocalProxy对象.method,执行getattr方法，getattr(self._get_current_object(), name) -self._get_current_object()返回return self.__local()，self.__local()，在LocakProxy实例化的时候,object.__setattr__(self, &#x27;_LocalProxy__local&#x27;, local),此处local就是：partial(_lookup_req_object, &#x27;request&#x27;) -def _lookup_req_object(name): top = _request_ctx_stack.top #_request_ctx_stack 就是LocalStack()对象，top方法把ctx取出来 if top is None: raise RuntimeError(_request_ctx_err_msg) return getattr(top, name)#获取ctx中的request或session对象第三阶段：请求处理完毕 - 获取session并保存到cookie - 将ctx删除 程序运行，两个LocalStack()对象，一个里面放request和session，另一个放g和current_app 14.g对象 专门用来存储用户信息的g对象，g的全称的为global g对象在一次请求中的所有的代码的地方，都是可以使用的 g对象和session的区别 1session对象是可以跨request的，只要session还未失效，不同的request的请求会获取到同一个session，但是g对象不是，g对象不需要管过期时间，请求一次就g对象就改变了一次，或者重新赋值了一次 15.flask-session 作用：将默认保存的签名cookie中的值 保存到 redis/memcached/file/Mongodb/SQLAlchemy 安装：pip3 install flask-session 使用1： 1234567891011121314from flask import Flask,sessionfrom flask_session import RedisSessionInterfaceimport redisapp = Flask(__name__)conn=redis.Redis(host=&#x27;127.0.0.1&#x27;,port=6379)#use_signer是否对key签名app.session_interface=RedisSessionInterface(conn,key_prefix=&#x27;lqz&#x27;)@app.route(&#x27;/&#x27;)def hello_world(): session[&#x27;name&#x27;]=&#x27;lqz&#x27; return &#x27;Hello World!&#x27;if __name__ == &#x27;__main__&#x27;: app.run() 使用2： 12345from redis import Redisfrom flask.ext.session import Sessionapp.config[&#x27;SESSION_TYPE&#x27;] = &#x27;redis&#x27;app.config[&#x27;SESSION_REDIS&#x27;] = Redis(host=&#x27;192.168.0.94&#x27;,port=&#x27;6379&#x27;)Session(app) 问题：设置cookie时，如何设定关闭浏览器则cookie失效。 1234response.set_cookie(&#x27;k&#x27;,&#x27;v&#x27;,exipre=None)#这样设置即可#在session中设置app.session_interface=RedisSessionInterface(conn,key_prefix=&#x27;lqz&#x27;,permanent=False)#一般不用，我们一般都设置超时时间，多长时间后失效 问题：cookie默认超时时间是多少？如何设置超时时间 12#源码expires = self.get_expiration_time(app, session)&#x27;PERMANENT_SESSION_LIFETIME&#x27;: timedelta(days=31),#这个配置文件控制 16.数据库连接池 pymsql链接数据库 123456789101112import pymysqlconn = pymysql.connect(host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, passwd=&#x27;123456&#x27;, db=&#x27;s8day127db&#x27;)cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)# cursor.execute(&quot;select id,name from users where name=%s and pwd=%s&quot;,[&#x27;lqz&#x27;,&#x27;123&#x27;,])cursor.execute(&quot;select id,name from users where name=%(user)s and pwd=%(pwd)s&quot;,&#123;&#x27;user&#x27;:&#x27;lqz&#x27;,&#x27;pwd&#x27;:&#x27;123&#x27;&#125;)obj = cursor.fetchone()conn.commit()cursor.close()conn.close()print(obj) 数据库连接池版 setting.py 123456789101112131415161718192021222324252627282930313233343536373839404142from datetime import timedeltafrom redis import Redisimport pymysqlfrom DBUtils.PooledDB import PooledDB, SharedDBConnectionclass Config(object): DEBUG = True SECRET_KEY = &quot;umsuldfsdflskjdf&quot; PERMANENT_SESSION_LIFETIME = timedelta(minutes=20) SESSION_REFRESH_EACH_REQUEST= True SESSION_TYPE = &quot;redis&quot; PYMYSQL_POOL = PooledDB( creator=pymysql, # 使用链接数据库的模块 maxconnections=6, # 连接池允许的最大连接数，0和None表示不限制连接数 mincached=2, # 初始化时，链接池中至少创建的空闲的链接，0表示不创建 maxcached=5, # 链接池中最多闲置的链接，0和None不限制 maxshared=3, # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。 blocking=True, # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错 maxusage=None, # 一个链接最多被重复使用的次数，None表示无限制 setsession=[], # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;] ping=0, # ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123456&#x27;, database=&#x27;s8day127db&#x27;, charset=&#x27;utf8&#x27; )class ProductionConfig(Config): SESSION_REDIS = Redis(host=&#x27;192.168.0.94&#x27;, port=&#x27;6379&#x27;)class DevelopmentConfig(Config): SESSION_REDIS = Redis(host=&#x27;127.0.0.1&#x27;, port=&#x27;6379&#x27;)class TestingConfig(Config): pass utils/sql.py 1234567891011121314151617181920212223242526272829303132import pymysqlfrom settings import Configclass SQLHelper(object): @staticmethod def open(cursor): POOL = Config.PYMYSQL_POOL conn = POOL.connection() cursor = conn.cursor(cursor=cursor) return conn,cursor @staticmethod def close(conn,cursor): conn.commit() cursor.close() conn.close() @classmethod def fetch_one(cls,sql,args,cursor =pymysql.cursors.DictCursor): conn,cursor = cls.open(cursor) cursor.execute(sql, args) obj = cursor.fetchone() cls.close(conn,cursor) return obj @classmethod def fetch_all(cls,sql, args,cursor =pymysql.cursors.DictCursor): conn, cursor = cls.open(cursor) cursor.execute(sql, args) obj = cursor.fetchall() cls.close(conn, cursor) return obj 使用： 1obj = SQLHelper.fetch_one(&quot;select id,name from users where name=%(user)s and pwd=%(pwd)s&quot;, form.data) 17.wtforms 安装:pip3 install wtforms 使用1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from flask import Flask, render_template, request, redirectfrom wtforms import Formfrom wtforms.fields import simplefrom wtforms import validatorsfrom wtforms import widgetsapp = Flask(__name__, template_folder=&#x27;templates&#x27;)app.debug = Trueclass LoginForm(Form): # 字段（内部包含正则表达式） name = simple.StringField( label=&#x27;用户名&#x27;, validators=[ validators.DataRequired(message=&#x27;用户名不能为空.&#x27;), validators.Length(min=6, max=18, message=&#x27;用户名长度必须大于%(min)d且小于%(max)d&#x27;) ], widget=widgets.TextInput(), # 页面上显示的插件 render_kw=&#123;&#x27;class&#x27;: &#x27;form-control&#x27;&#125; ) # 字段（内部包含正则表达式） pwd = simple.PasswordField( label=&#x27;密码&#x27;, validators=[ validators.DataRequired(message=&#x27;密码不能为空.&#x27;), validators.Length(min=8, message=&#x27;用户名长度必须大于%(min)d&#x27;), validators.Regexp(regex=&quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[$@$!%*?&amp;])[A-Za-z\\d$@$!%*?&amp;]&#123;8,&#125;&quot;, message=&#x27;密码至少8个字符，至少1个大写字母，1个小写字母，1个数字和1个特殊字符&#x27;) ], widget=widgets.PasswordInput(), render_kw=&#123;&#x27;class&#x27;: &#x27;form-control&#x27;&#125; )@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login(): if request.method == &#x27;GET&#x27;: form = LoginForm() return render_template(&#x27;login.html&#x27;, form=form) else: form = LoginForm(formdata=request.form) if form.validate(): print(&#x27;用户提交数据通过格式验证，提交的值为：&#x27;, form.data) else: print(form.errors) return render_template(&#x27;login.html&#x27;, form=form)if __name__ == &#x27;__main__&#x27;: app.run() login.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录&lt;/h1&gt;&lt;form method=&quot;post&quot;&gt; &lt;p&gt;&#123;&#123;form.name.label&#125;&#125; &#123;&#123;form.name&#125;&#125; &#123;&#123;form.name.errors[0] &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;form.pwd.label&#125;&#125; &#123;&#123;form.pwd&#125;&#125; &#123;&#123;form.pwd.errors[0] &#125;&#125;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 使用2： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140from flask import Flask, render_template, request, redirectfrom wtforms import Formfrom wtforms.fields import corefrom wtforms.fields import html5from wtforms.fields import simplefrom wtforms import validatorsfrom wtforms import widgetsapp = Flask(__name__, template_folder=&#x27;templates&#x27;)app.debug = Trueclass RegisterForm(Form): name = simple.StringField( label=&#x27;用户名&#x27;, validators=[ validators.DataRequired() ], widget=widgets.TextInput(), render_kw=&#123;&#x27;class&#x27;: &#x27;form-control&#x27;&#125;, default=&#x27;alex&#x27; ) pwd = simple.PasswordField( label=&#x27;密码&#x27;, validators=[ validators.DataRequired(message=&#x27;密码不能为空.&#x27;) ], widget=widgets.PasswordInput(), render_kw=&#123;&#x27;class&#x27;: &#x27;form-control&#x27;&#125; ) pwd_confirm = simple.PasswordField( label=&#x27;重复密码&#x27;, validators=[ validators.DataRequired(message=&#x27;重复密码不能为空.&#x27;), validators.EqualTo(&#x27;pwd&#x27;, message=&quot;两次密码输入不一致&quot;) ], widget=widgets.PasswordInput(), render_kw=&#123;&#x27;class&#x27;: &#x27;form-control&#x27;&#125; ) email = html5.EmailField( label=&#x27;邮箱&#x27;, validators=[ validators.DataRequired(message=&#x27;邮箱不能为空.&#x27;), validators.Email(message=&#x27;邮箱格式错误&#x27;) ], widget=widgets.TextInput(input_type=&#x27;email&#x27;), render_kw=&#123;&#x27;class&#x27;: &#x27;form-control&#x27;&#125; ) gender = core.RadioField( label=&#x27;性别&#x27;, choices=( (1, &#x27;男&#x27;), (2, &#x27;女&#x27;), ), coerce=int # “1” “2” ) city = core.SelectField( label=&#x27;城市&#x27;, choices=( (&#x27;bj&#x27;, &#x27;北京&#x27;), (&#x27;sh&#x27;, &#x27;上海&#x27;), ) ) hobby = core.SelectMultipleField( label=&#x27;爱好&#x27;, choices=( (1, &#x27;篮球&#x27;), (2, &#x27;足球&#x27;), ), coerce=int ) favor = core.SelectMultipleField( label=&#x27;喜好&#x27;, choices=( (1, &#x27;篮球&#x27;), (2, &#x27;足球&#x27;), ), widget=widgets.ListWidget(prefix_label=False), option_widget=widgets.CheckboxInput(), coerce=int, default=[1, 2] ) def __init__(self, *args, **kwargs): super(RegisterForm, self).__init__(*args, **kwargs) self.favor.choices = ((1, &#x27;篮球&#x27;), (2, &#x27;足球&#x27;), (3, &#x27;羽毛球&#x27;)) def validate_pwd_confirm(self, field): &quot;&quot;&quot; 自定义pwd_confirm字段规则，例：与pwd字段是否一致 :param field: :return: &quot;&quot;&quot; # 最开始初始化时，self.data中已经有所有的值 if field.data != self.data[&#x27;pwd&#x27;]: # raise validators.ValidationError(&quot;密码不一致&quot;) # 继续后续验证 raise validators.StopValidation(&quot;密码不一致&quot;) # 不再继续后续验证@app.route(&#x27;/register&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def register(): if request.method == &#x27;GET&#x27;: form = RegisterForm(data=&#123;&#x27;gender&#x27;: 2,&#x27;hobby&#x27;:[1,]&#125;) # initial return render_template(&#x27;register.html&#x27;, form=form) else: form = RegisterForm(formdata=request.form) if form.validate(): print(&#x27;用户提交数据通过格式验证，提交的值为：&#x27;, form.data) else: print(form.errors) return render_template(&#x27;register.html&#x27;, form=form)if __name__ == &#x27;__main__&#x27;: app.run()&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户注册&lt;/h1&gt;&lt;form method=&quot;post&quot; novalidate style=&quot;padding:0 50px&quot;&gt; &#123;% for field in form %&#125; &lt;p&gt;&#123;&#123;field.label&#125;&#125;: &#123;&#123;field&#125;&#125; &#123;&#123;field.errors[0] &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 18.信号 Flask框架中的信号基于blinker，其主要就是让开发者可是在flask请求过程中定制一些用户行为 安装：pip3 install blinker 内置信号： 1234567891011121314request_started = _signals.signal(&#x27;request-started&#x27;) # 请求到来前执行request_finished = _signals.signal(&#x27;request-finished&#x27;) # 请求结束后执行 before_render_template = _signals.signal(&#x27;before-render-template&#x27;) # 模板渲染前执行template_rendered = _signals.signal(&#x27;template-rendered&#x27;) # 模板渲染后执行 got_request_exception = _signals.signal(&#x27;got-request-exception&#x27;) # 请求执行出现异常时执行 request_tearing_down = _signals.signal(&#x27;request-tearing-down&#x27;) # 请求执行完毕后自动执行（无论成功与否）appcontext_tearing_down = _signals.signal(&#x27;appcontext-tearing-down&#x27;)# 应用上下文执行完毕后自动执行（无论成功与否） appcontext_pushed = _signals.signal(&#x27;appcontext-pushed&#x27;) # 应用上下文push时执行appcontext_popped = _signals.signal(&#x27;appcontext-popped&#x27;) # 应用上下文pop时执行message_flashed = _signals.signal(&#x27;message-flashed&#x27;) # 调用flask在其中添加数据时，自动触发 使用信号： 123456789101112131415161718192021222324252627282930from flask import Flask,signals,render_templateapp = Flask(__name__)# 往信号中注册函数def func(*args,**kwargs): print(&#x27;触发型号&#x27;,args,kwargs)signals.request_started.connect(func)# 触发信号： signals.request_started.send()@app.before_first_requestdef before_first1(*args,**kwargs): pass@app.before_first_requestdef before_first2(*args,**kwargs): pass@app.before_requestdef before_first3(*args,**kwargs): pass@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&quot;POST&quot;])def index(): print(&#x27;视图&#x27;) return render_template(&#x27;index.html&#x27;)if __name__ == &#x27;__main__&#x27;: app.wsgi_app app.run() 一个流程中的信号触发点（了解） 1234567891011121314a. before_first_requestb. 触发 request_started 信号c. before_requestd. 模板渲染 渲染前的信号 before_render_template.send(app, template=template, context=context) rv = template.render(context) # 模板渲染 渲染后的信号 template_rendered.send(app, template=template, context=context)e. after_requestf. session.save_session()g. 触发 request_finished信号 如果上述过程出错： 触发错误处理信号 got_request_exception.send(self, exception=e) h. 触发信号 request_tearing_down 自定义信号(了解)： 12345678910111213141516171819from flask import Flask, current_app, flash, render_templatefrom flask.signals import _signalsapp = Flask(import_name=__name__)# 自定义信号xxxxx = _signals.signal(&#x27;xxxxx&#x27;) def func(sender, *args, **kwargs): print(sender)# 自定义信号中注册函数xxxxx.connect(func)@app.route(&quot;/x&quot;)def index(): # 触发信号 xxxxx.send(&#x27;123123&#x27;, k1=&#x27;v1&#x27;) return &#x27;Index&#x27; if __name__ == &#x27;__main__&#x27;: app.run() 19.多app应用 12345678910111213141516171819202122from werkzeug.wsgi import DispatcherMiddlewarefrom werkzeug.serving import run_simplefrom flask import Flask, current_appapp1 = Flask(&#x27;app01&#x27;)app2 = Flask(&#x27;app02&#x27;)@app1.route(&#x27;/index&#x27;)def index(): return &quot;app01&quot;@app2.route(&#x27;/index2&#x27;)def index2(): return &quot;app2&quot;# http://www.oldboyedu.com/index# http://www.oldboyedu.com/sec/index2dm = DispatcherMiddleware(app1, &#123; &#x27;/sec&#x27;: app2,&#125;)if __name__ == &quot;__main__&quot;: run_simple(&#x27;localhost&#x27;, 5000, dm) 20.flask-script 用于实现类似于django中 python3 manage.py runserver …类似的命令 安装：pip3 install flask-script 使用 12345678from flask_script import Managerapp = Flask(__name__)manager=Manager(app)...if __name__ == &#x27;__main__&#x27;: manager.run()#以后在执行，直接：python3 manage.py runserver#python3 manage.py runserver --help 自定制命令 12345678910111213141516171819202122232425@manager.commanddef custom(arg): &quot;&quot;&quot; 自定义命令 python manage.py custom 123 :param arg: :return: &quot;&quot;&quot; print(arg)@manager.option(&#x27;-n&#x27;, &#x27;--name&#x27;, dest=&#x27;name&#x27;)#@manager.option(&#x27;-u&#x27;, &#x27;--url&#x27;, dest=&#x27;url&#x27;)def cmd(name, url): &quot;&quot;&quot; 自定义命令（-n也可以写成--name） 执行： python manage.py cmd -n lqz -u http://www.oldboyedu.com 执行： python manage.py cmd --name lqz --url http://www.oldboyedu.com :param name: :param url: :return: &quot;&quot;&quot; print(name, url)#有什么用？#把excel的数据导入数据库，定制个命令，去执行 21flask-admin 安装 1pip3 install flask_admin 简单使用 123456789101112from flask import Flaskfrom flask_admin import Adminapp = Flask(__name__)#将app注册到adminzhong admin = Admin(app)if __name__==&quot;mian&quot;: app.run()#访问#127.0.0.1:5000/admin端口，会得到一个空白的页面 将表模型注册到admin中 1234567891011121314#在将表注册之前应该对app进行配置SQLALCHEMY_DATABASE_URI = &quot;mysql+pymysql://root:@127.0.0.1:3307/py9api?charset=utf8mb4&quot;SQLALCHEMY_POOL_SIZE = 5SQLALCHEMY_POOL_TIMEOUT = 30SQLALCHEMY_POOL_RECYCLE = -1#导入models文件的中的表模型from flask_admin.contrib.sqla import ModelViewfrom api.models import Stock,Product,Images,Category,Wxuser,Banneradmin.add_view(ModelView(Stock, db.session))admin.add_view(ModelView(Product, db.session))admin.add_view(ModelView(Category, db.session)) 如果有个字段是图片指端 123456789101112131415161718#配置上传文件的路径#导入from flask_admin.contrib.fileadmin import FileAdminfrom flask_admin.contrib.fileadmin import FileAdmin,formfile_path = op.join(op.dirname(__file__), &#x27;static&#x27;)admin = Admin(app)admin.add_view(FileAdmin(file_path, &#x27;/static/&#x27;, name=&#x27;文件&#x27;))#如果有个字段要是上传文件重写该方法的modleView类，假设imgae_url是文件图片的字段class ImagesView(ModelView): form_extra_fields = &#123; &#x27;image_url&#x27;: form.ImageUploadField(&#x27;Image&#x27;, base_path=file_path, relative_path=&#x27;uploadFile/&#x27; ) &#125;admin.add_view(ImagesView(Images, db.session))","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"8-5 数据库连接池","slug":"flask/8-5 数据库连接池","date":"2021-01-18T11:39:27.117Z","updated":"2021-01-18T14:10:48.074Z","comments":true,"path":"2021/01/18/flask/8-5 数据库连接池/","link":"","permalink":"http://example.com/2021/01/18/flask/8-5%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"","text":"01 如何在python中操作数据库 在后端开发中免不掉与数据库打交道，无非是使用orm或者原生sql来操作数据库。 在python中通过原生sql操作数据库，主流就两种。 使用pymysql模块：pymysql支持python2.x和python3.x的版本 使用mysqldb模块：mysqldb仅支持python2.x的版本 orm的使用以flask和django为例。 flask使用的orm是基于SQLAlchemy（SQLAlchemy本就是orm），flask团队并在SQLAlchemy基础之上又封装了一个Flask-SQLchemy并予以应用 。 django使用的orm是django自带的orm。 orm的操作数据库的方式我们已经熟知了，这里我们聊一聊如何在web中使用原生sql操作数据库，以及会出现的问题。 02 在web中使用原生sql(pymysql)操作数据库？ 2.1 在web中通过原生sql操作数据库会出现的问题。 示例1： 把所有的数据库操作全部都放在了视图函数里面。 12345678910111213141516171819202122232425from flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello(): import pymysql CONN = pymysql.connect(host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123&#x27;, database=&#x27;pooldb&#x27;, charset=&#x27;utf8&#x27;) cursor = CONN.cursor() cursor.execute(&#x27;select * from tb1&#x27;) result = cursor.fetchall() cursor.close() print(result) return &quot;Hello World&quot;if __name__ == &#x27;__main__&#x27;: app.run() 会出现的问题 很多个用户并发的来请求，一个用户可以理解为一个线程，每个线程都会跟数据库建立连接，数据库承受不了这种量级的连接数。 示例2 为了避免之前每个用户都建立连接，我们把数据库连接放到了全局变量里面，只会建立一次连接，但是依然会出现问题。 123456789101112131415161718192021222324from flask import Flaskapp = Flask(__name__)import pymysqlCONN = pymysql.connect(host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123&#x27;, database=&#x27;pooldb&#x27;, charset=&#x27;utf8&#x27;)@app.route(&quot;/&quot;)def hello(): cursor = CONN.cursor() cursor.execute(&#x27;select * from tb1&#x27;) result = cursor.fetchall() cursor.close() print(result) return &quot;Hello World&quot;if __name__ == &#x27;__main__&#x27;: app.run() 会出现的问题： 会出现线程安全问题，比如如果第一个用户拿到了连接给关闭了，而第二个用户正在进行查询，第二个用户查询的时候第一个用户把连接断了，会导致第二个用户出现问题。 假设第一用户查询了一下表1，正准备获取查询的内容，这时第二个人查询了一下表2，由于cursor对象都是同一个，第一个人获取到的查询内容就是表2的内容了，所以也会出现线程安全问题 示例3 为了避免之前的线程不安全，在示例2的基础上加上一把线程锁 12345678910111213141516171819202122232425from flask import Flaskimport threadingapp = Flask(__name__)import pymysqlCONN = pymysql.connect(host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123&#x27;, database=&#x27;pooldb&#x27;, charset=&#x27;utf8&#x27;)@app.route(&quot;/&quot;)def hello(): with threading.Lock(): cursor = CONN.cursor() cursor.execute(&#x27;select * from tb1&#x27;) result = cursor.fetchall() cursor.close() print(result) return &quot;Hello World&quot;if __name__ == &#x27;__main__&#x27;: app.run() 会出现的问题： 根据代码可以发现，只是在示例2的基础上加了一把线程锁，确实是保证了线程安全，但是所有关于数据库操作的请求变成了串行，无法实现并发了。 小结： 如果直接连接坐在视图函数中，会导致每个用户都要创建连接，数据库承受不了这种量级的连接数。 如果连接数据库的内容做成全局变量的话，无法保证线程安全。 如果定义全局变量用于连接数据库，并且在线程中操作数据库内容加线程锁头，就会变成串行，无法保证并发 所以我们既要控制数据库的连接数，又要保证线程安全，又要保证web的并发，这个时候最终的解决方案是数据库连接池。 2.1 什么是数据库连接池呢？ 数据库连接池概念：数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个，这项技术能明显提高对数据库操作的性能。 图解： 通俗的讲就是，假设数据库连接池中有5个连接对象，每个用户简单理解为一个线程，比如现在有6个用户同时来访问，6个线程去数据库连接池里面申请数据库的连接对象。前5个线程每个都申请到了连接对象去操作数据库，每个线程使用完了数据库连接对象会归还给数据库连接池，那么第6个线程会等待前5个线程归还连接对象给连接池，再具体一点是：假设第一个线程使用完了连接对象，那么此时6个线程才会结束等待，从而申请到连接对象，以此类推。 2.2 Python数据库连接池DBUtiles DBUtils 是Python的一个用于实现数据库连接池的模块。 首先安装一下DBUtils模块。 1pip install DBUtils DBUtils连接池的两种连接模式： **模式一：**为每个线程创建一个连接，线程即使调用了close方法，也不会关闭，只是把连接重新放到连接池，仅供自己的线程再次使用，当线程终止时，连接会自动关闭。（不推荐使用，因为这样需要自己控制线程数量） 1234567891011121314151617181920212223242526272829import pymysqlfrom DBUtils.PersistentDB import PersistentDBfrom threading import localPOOL = PersistentDB( creator=pymysql, # 使用链接数据库的模块 maxusage=None, # 一个链接最多被重复使用的次数，None表示无限制 setsession=[], # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;] ping=0, # ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always closeable=False, # 如果为False时， conn.close() 实际上被忽略，供下次使用，再线程关闭时，才会自动关闭链接。如果为True时， conn.close()则关闭链接，那么再次调用pool.connection时就会报错，因为已经真的关闭了连接（pool.steady_connection()可以获取一个新的链接） threadlocal=None, # 如果为none，用默认的threading.Loacl对象，否则可以自己封装一个local对象进行替换 host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123&#x27;, database=&#x27;pooldb&#x27;, charset=&#x27;utf8&#x27;)def func(): conn = POOL.connection(shareable=False) cursor = conn.cursor() cursor.execute(&#x27;select * from tb1&#x27;) result = cursor.fetchall() cursor.close() conn.close()func() **模式二：**创建一批连接到连接池，供所有线程共享使用。 123456789101112131415161718192021222324252627282930313233import timeimport pymysqlimport threadingfrom DBUtils.PooledDB import PooledDB, SharedDBConnectionPOOL = PooledDB( creator=pymysql, # 使用链接数据库的模块 maxconnections=6, # 连接池允许的最大连接数，0和None表示不限制连接数 mincached=2, # 初始化时，链接池中至少创建的空闲的链接，0表示不创建 maxcached=5, # 链接池中最多闲置的链接，0和None不限制 maxshared=3, # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。 blocking=True, # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错 maxusage=None, # 一个链接最多被重复使用的次数，None表示无限制 setsession=[], # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;] ping=0, # ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123&#x27;, database=&#x27;pooldb&#x27;, charset=&#x27;utf8&#x27;)def func(): conn = POOL.connection() cursor = conn.cursor() cursor.execute(&#x27;select * from tb1&#x27;) result = cursor.fetchall() conn.close()func() 2.3 实际开发小应用案例： 案例目录： 12- app.py- db_helper.py app.py 1234567891011121314from flask import Flaskfrom db_helper import SQLHelperapp = Flask(__name__)@app.route(&quot;/&quot;)def hello(): result = SQLHelper.fetch_one(&#x27;select * from t1&#x27;,[]) print(result) return &quot;Hello World&quot;if __name__ == &#x27;__main__&#x27;: app.run() db_helper.py 1234567891011121314151617181920212223242526272829303132333435363738394041import pymysqlfrom DBUtils.PooledDB import PooledDBPOOL = PooledDB( creator=pymysql, # 使用链接数据库的模块 maxconnections=6, # 连接池允许的最大连接数，0和None表示不限制连接数 mincached=2, # 初始化时，链接池中至少创建的空闲的链接，0表示不创建 maxcached=5, # 链接池中最多闲置的链接，0和None不限制 maxshared=3, # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。 blocking=True, # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错 maxusage=None, # 一个链接最多被重复使用的次数，None表示无限制 setsession=[], # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;] ping=0, # ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123&#x27;, database=&#x27;pooldb&#x27;, charset=&#x27;utf8&#x27;)class SQLHelper(object): @staticmethod def fetch_one(sql,args): conn = POOL.connection() cursor = conn.cursor() cursor.execute(sql, args) result = cursor.fetchone() conn.close() return result @staticmethod def fetch_all(self,sql,args): conn = POOL.connection() cursor = conn.cursor() cursor.execute(sql, args) result = cursor.fetchall() conn.close() return result 以后在开发的过程中我们可以基于数据库连接池，基于pymysql，来实现自己个性化操作数据库的需求。","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"8-4 flask请求上下文","slug":"flask/8-4 flask请求上下文","date":"2021-01-18T11:39:27.112Z","updated":"2021-01-18T14:10:56.230Z","comments":true,"path":"2021/01/18/flask/8-4 flask请求上下文/","link":"","permalink":"http://example.com/2021/01/18/flask/8-4%20flask%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87/","excerpt":"","text":"在分析上下问之前，要做好一个心理准备，因为设计到的代码会很多，需要不懂的要跟着文档自己去翻阅源码。 首先把涉及到的主要的类或者设计到的 py 页面展示如下图。下面我会以对应类或者页面去讲解flask源码 之前我们已经论述过了，每次请求过来都会触发app()，所以会触发FLask类的__call__方法，__call__方法会触发Flask类的wsgi_app()方法。然后所有的请求的整个生命周期都在整个wsgi_app()里面了。 根据上图类和序号来完成我们的分析流程。 1 首先分析请求上下文对象(ctx)创立 1.0 FLask 类中的wsgi_app()中的 ctx = self.request_context(environ） 1.1 RequestContext类中的 __init__ 实例化出请求上下文对象ctx 并且关注： 123if request is None: request = app.request_class(environ)self.request = request 1.2 Request类中的 __init__ 该类的 __init__方法实例化出reqeust对象 这三部完成了初始化一个用户请求相关的数据，也就是请求上下文对象。 1.0中的ctx就是RequestContext对象，请求上下文对象ctx中初始化所有请求所有内容，并且其内部封装着Request对象，Request对象把请求过来的信息格式化并且储存起来。 2 把请求对象(ctx)添加到local中（入栈） 2.0 FLask 类中的wsgi_app()中的 ctx.push() 2.1 RequestContext 类中的 push() 下 只关注_request_ctx_stack.push(self) 2.2 LocalStack类中的 push()方法 只关注 self._local.stack = rv = []，触发2.3执行。 在实现了2.3的基础上，关注本方法中的rv.append(obj) , rv就是2.3中stack的value值，此obj就是ctx对象 ，相当于为Local类中的storage里面的当前线程或携程唯一标识里的stack对应的value值，添加了球队上下文对象ctx，这个对象里面包含了所有请求过来的信息。 { 线程或携程唯一标识:{ stack:[请求上下文对象ctx]。 }， } 2.3 Local类中的 __setattr__方法实现了创建了 storage = { 线程或携程唯一标识:{ stack: [ ] }， } 3 找到视图函数并且使用导入request对象** 3.0 FLask 类中的wsgi_app()中 response = self.full_dispatch_request()的找到视图函数并执行 3.1 找到了视图函数并且执行request.method方法。 1234@app.route(&#39;&#x2F;&#39;)def index(): v &#x3D; request.method return v 3.2 须知：request = LocalProxy(partial(_lookup_req_object, 'request')) 用于在视图函数里导入的request对象 偏函数：partial(_lookup_req_object, 'request')不懂可以翻阅之前的文章 3.3 触发了LocalProxy类 中的 __getattr__ 关注：return getattr(self._get_current_object(), name) # name是‘method’，去Request类中查询‘method’属性， 3.4 触发了LocalProxy类 中的 _get_current_object() 关注 return self.__local() #返回了Request对象 在LocalProxy类实例化的时候使得self.__local的值就是实例化时传入偏函数。所以会返回偏函数运行结果。 3.5 触发了globals.py 里的 _lookup_req_object()运行。 关注 top = _request_ctx_stack.top # 触发3.6执行 return getattr(top, name) # name = ‘request’，所以返回了Request对象 3.6 触发了LocalStack类中的top()方法： 关注 return self._local.stack[-1] # 返回了请求上下文ctx对象。 3.7 触发了Local类中的__getattr__（）方法 关注return self.__storage__[self.__ident_func__()][name] #返回了当前线程或携程的stack对应的value值，可以理解为返回了 [ctx对象] 4 请求结束时从Local中移除上下文对象（出栈） 经过了添加请求上下文到Local的storage中，以及视图函数的运行返回相应对象，我们现在进行把请求上下文对象从storage中移除。 4.0 FLask 类中的wsgi_app()中 ctx.auto_pop() 4.1 触发了 RequestContext类中的 auto_pop() 关注 self.pop() 4.2 触发了 RequestContext类中的 pop() 方法 rv = _request_ctx_stack.pop() 4.3 触发了 LocalStack类中的pop()的pop方法 123elif len(stack) == 1: # 证明push过一次 添加过了一次对象 release_local(self._local) # 在这里pop掉该线程。release_local pop掉的是一个字典 return stack[-1] 4.4 触发了 Local类中的__release_local__() 方法 self.__storage__.pop(self.__ident_func__(), None) #在Local对象中删除掉了当前线程或者携程的请求上下文对象， 总结 其实操作flask的请求上下文就是操作Local中的字典__storage__ 通过REquestContext类首先实例化ctx请求上下文对象，其内部包含请求对象 入栈，通过请求上下文对象的类的push()方法触发了LocalStack类的push() 方法，从而添加到Local类中的字典里。 观察导入的request源码 ，通过观察LocalProxy的源码，最后触发了LocalStack的top()方法得到上下文对象，再的到请求对象，从而实现reuqest的功能。 出站，和入栈原理相同通过请求上下文对象的类的方法，触发了LocalStack的pop()方法从而从字典中删除掉当前线程或当前携程的请求信息。","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"8-3 阅读flask上下文前夕补充","slug":"flask/8-3 阅读flask上下文前补充","date":"2021-01-18T11:39:27.107Z","updated":"2021-01-18T14:11:04.433Z","comments":true,"path":"2021/01/18/flask/8-3 阅读flask上下文前补充/","link":"","permalink":"http://example.com/2021/01/18/flask/8-3%20%E9%98%85%E8%AF%BBflask%E4%B8%8A%E4%B8%8B%E6%96%87%E5%89%8D%E8%A1%A5%E5%85%85/","excerpt":"","text":"0 预读源码必要了解的知识点 在阅读源码之前，源码中会涉及到很多python类的特殊的用法以及类写好的功能组件，所以这里我们做一个补充，以便于接下来源码的阅读 01 偏函数 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 12345678910111213from functools import partialdef func(a1,a2,a3): print(a1,a2,a3)new_func1 = partial(func,a1=1,a2=2)new_func1(a3=3)new_func2 = partial(func,1,2)new_func2(3)new_func3 = partial(func,a1=1)new_func3(a2=2,a3=3) 注：partial括号内第一个参数是原函数，其余参数是需要固定的参数 效果图： 02 __add__的使用 如果一个类里面定义了 __add__方法，如果这个类的对象 +另一个对象，会触发这个类的__add__方法，换个说法如果 对象1+对象2 则会触发对象1的 __add__方法，python在类中有很多类似的方法，对象会在不同情况下出发对应的方法。 123456789101112131415class Foo: def __init__(self): self.num = 1 def __add__(self, other): if isinstance(other,Foo): result = self.num + other.num else: result = self.num + other return resultfo1 = Foo()fo2 = Foo()v1 = fo1 + fo2v2 = fo1 + 4print(v1,v2) 效果图： 03 chain函数 chain函数来自于itertools库，itertools库提供了非常有用的基于迭代对象的函数，而chain函数则是可以串联多个迭代对象来形成一个更大的迭代对象 。 示例1 123456789from itertools import chainl1 = [1,2,3]l2 = [4,5]new_iter = chain(l1,l2) # 参数必须为可迭代对象print(new_iter)for i in new_iter: print(i) 效果图： 示例2 123456789101112131415from itertools import chaindef f1(x): return x+1def f2(x): return x+2def f3(x): return x+3list_4 = [f1, f2]new_iter2 = chain([f3], list_4)for i in new_iter2: print(i) 效果图： 作者： 小猿取经","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"8-2 flask之分析线程和协程","slug":"flask/8-2 flask之分析线程和协程","date":"2021-01-18T11:39:27.102Z","updated":"2021-01-18T14:11:12.236Z","comments":true,"path":"2021/01/18/flask/8-2 flask之分析线程和协程/","link":"","permalink":"http://example.com/2021/01/18/flask/8-2%20flask%E4%B9%8B%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"01 思考：每个请求之间的关系 我们每一个请求进来的时候都开一个进程肯定不合理，那么如果每一个请求进来都是串行的，那么根本实现不了并发，所以我们假定每一个请求进来使用的是线程。 那么线程中数据互相不隔离，存在修改数据的时候数据不安全的问题。 假定我们的需求是，每个线程都要设置值，并且该线程打印该线程修改的值。 123456789101112131415161718from threading import Thread,current_threadimport timeclass Foo(object): def __init__(self): self.name = 0locals_values = Foo()def func(num): locals_values.name = num time.sleep(2) # 取出该线程的名字 print(locals_values.name, current_thread().name)for i in range(10): # 设置该线程的名字 t = Thread(target=func,args=(i,),name=&#x27;线程%s&#x27;%i) t.start() 很明显阻塞了2秒的时间所有的线程都完成了修改值，而2秒后所有的线程打印出来的时候都是9了，就产生了数据不安全的问题。 所以我们要解决这种线程不安全的问题，有如下两种解决方案。 方案一：是加锁 方案二：使用threading.local对象把要修改的数据复制一份，使得每个数据互不影响。 我们要实现的并发是多个请求实现并发，而不是纯粹的只是修改一个数据，所以第二种思路更适合做我们每个请求的并发，把每个请求对象的内容都复制一份让其互相不影响。 详解：为什么不用加锁的思路？加锁的思路是多个线程要真正实现共用一个数据，并且该线程修改了数据之后会影响到其他线程，更适合类似于12306抢票的应用场景，而我们是要做请求对象的并发，想要实现的是该线程对于请求对象这部分内容有任何修改并不影响其他线程。所以使用方案二 02 threading.local 多个线程修改同一个数据，复制多份数据给每个线程用,为每个线程开辟一块空间进行数据存储 实例： 1234567891011121314from threading import Thread,current_thread,localimport timelocals_values = local()# 可以简单理解为，识别到新的线程的时候，都会开辟一片新的内存空间，相当于每个线程对该值进行了拷贝。def func(num): locals_values.name = num time.sleep(2) print(locals_values.name, current_thread().name)for i in range(10): t = Thread(target=func,args=(i,),name=&#x27;线程%s&#x27;%i) t.start() 如上通过threading.local实例化的对象，实现了多线程修改同一个数据，每个线程都复制了一份数据，并且修改的也都是自己的数据。达到了我们想要的效果。 03 通过字典自定义threading.local 实例： 1234567891011121314151617181920212223242526272829from threading import get_ident,Thread,current_thread# get_ident()可以获取每个线程的唯一标记，import timeclass Local(object): storage = &#123;&#125;# 初始化一个字典 get_ident = get_ident # 拿到get_ident的地址 def set(self,k,v): ident =self.get_ident()# 获取当前线程的唯一标记 origin = self.storage.get(ident) if not origin: origin=&#123;&#125; origin[k] = v self.storage[ident] = origin def get(self,k): ident = self.get_ident() # 获取当前线程的唯一标记 v= self.storage[ident].get(k) return vlocals_values = Local()def func(num): # get_ident() 获取当前线程的唯一标记 locals_values.set(&#x27;KEY&#x27;,num) time.sleep(2) print(locals_values.get(&#x27;KEY&#x27;),current_thread().name)for i in range(10): t = Thread(target=func,args=(i,),name=&#x27;线程%s&#x27;%i) t.start() 讲解： 利用get_ident()获取每个线程的唯一标记作为键，然后组织一个字典storage。 如：｛线程1的唯一标记：{k:v}，线程2的唯一标记：{k:v}…｝ 123456789101112｛15088: &#123;&#x27;KEY&#x27;: 0&#125;, 8856: &#123;&#x27;KEY&#x27;: 1&#125;, 17052: &#123;&#x27;KEY&#x27;: 2&#125;, 8836: &#123;&#x27;KEY&#x27;: 3&#125;, 13832: &#123;&#x27;KEY&#x27;: 4&#125;, 15504: &#123;&#x27;KEY&#x27;: 5&#125;, 16588: &#123;&#x27;KEY&#x27;: 6&#125;, 5164: &#123;&#x27;KEY&#x27;: 7&#125;, 560: &#123;&#x27;KEY&#x27;: 8&#125;, 1812: &#123;&#x27;KEY&#x27;: 9&#125; &#125; 运行效果： 04 通过setattr和getattr实现自定义threthreading.local 实例： 123456789101112131415161718192021222324252627282930from threading import get_ident,Thread,current_thread# get_ident()可以获取每个线程的唯一标记，import timeclass Local(object): storage = &#123;&#125;# 初始化一个字典 get_ident = get_ident # 拿到get_ident的地址 def __setattr__(self, k, v): ident =self.get_ident()# 获取当前线程的唯一标记 origin = self.storage.get(ident) if not origin: origin=&#123;&#125; origin[k] = v self.storage[ident] = origin def __getattr__(self, k): ident = self.get_ident() # 获取当前线程的唯一标记 v= self.storage[ident].get(k) return vlocals_values = Local()def func(num): # get_ident() 获取当前线程的唯一标记 locals_values.KEY=num time.sleep(2) print(locals_values.KEY,current_thread().name)for i in range(10): t = Thread(target=func,args=(i,),name=&#x27;线程%s&#x27;%i) t.start() 05 每个对象有自己的存储空间（字典） 我们可以自定义实现了threading.local的功能，但是现在存在一个问题，如果我们想生成多个Local对象，但是会导致多个Local对象所管理的线程设置的内容都放到了类属性storage = {}里面，所以我们如果想实现每一个Local对象所对应的线程设置的内容都放到自己的storage里面，就需要重新设计代码。 实例： 12345678910111213141516171819202122232425262728293031323334353637from threading import get_ident,Thread,current_thread# get_ident()可以获取每个线程的唯一标记，import timeclass Local(object): def __init__(self): # 千万不要按照注释里这么写，否则会造成递归死循环，死循环在__getattr__中,不理解的话可以全程使用debug测试。 # self.storage = &#123;&#125; # self.get_ident =get_ident object.__setattr__(self,&quot;storage&quot;,&#123;&#125;) object.__setattr__(self,&quot;get_ident&quot;,get_ident) #借用父类设置对象的属性，避免递归死循环。 def __setattr__(self, k, v): ident =self.get_ident()# 获取当前线程的唯一标记 origin = self.storage.get(ident) if not origin: origin=&#123;&#125; origin[k] = v self.storage[ident] = origin def __getattr__(self, k): ident = self.get_ident() # 获取当前线程的唯一标记 v= self.storage[ident].get(k) return vlocals_values = Local()locals_values2 = Local()def func(num): # get_ident() 获取当前线程的唯一标记 # locals_values.set(&#x27;KEY&#x27;,num) locals_values.KEY=num time.sleep(2) print(locals_values.KEY,current_thread().name) # print(&#x27;locals_values2.storage：&#x27;,locals_values2.storage) #查看locals_values2.storage的私有的storagefor i in range(10): t = Thread(target=func,args=(i,),name=&#x27;线程%s&#x27;%i) t.start() 显示效果我们就不做演示了，和前几个案例演示效果一样。 06 如果是你会如何设计flask的请求并发？ 情况一：单进程单线程，基于全局变量就可以做 情况二：单进程多线程，基于threading.local对象做 情况三：单进程多线程多协程，如何做？ 提示：协程属于应用级别的，协程会替代操作系统自动切换遇到 IO的任务或者运行级别低的任务，而应用级别的切换速度远高于操作系统的切换 当然如果是自己来设计框架，为了提升程序的并发性能，一定是上诉的情况三，不光考虑多线程并且要多协程，那么该如何设计呢？ 在我们的flask中为了这种并发需求，依赖于底层的werkzeug外部包，werkzeug实现了保证多线程和多携程的安全，werkzeug基本的设计理念和上一个案例一致，唯一的区别就是在导入的时候做了一步处理，且看werkzeug源码。 werkzeug.local.py部分源码 1234567891011121314151617181920212223242526272829303132...try: from greenlet import getcurrent as get_ident # 拿到携程的唯一标识except ImportError: try: from thread import get_ident #线程的唯一标识 except ImportError: from _thread import get_identclass Local(object): ... def __init__(self): object.__setattr__(self, &#x27;__storage__&#x27;, &#123;&#125;) object.__setattr__(self, &#x27;__ident_func__&#x27;, get_ident) ... def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; 讲解： 原理就是在最开始导入线程和协程的唯一标识的时候统一命名为get_ident，并且先导入协程模块的时候如果报错说明不支持协程，就会去导入线程的get_ident，这样无论是只有线程运行还是协程运行都可以获取唯一标识，并且把这个标识的线程或协程需要设置的内容都分类存放于__storage__字典中。","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"8-1 flask高级","slug":"flask/8-1 flask高级","date":"2021-01-18T11:39:27.097Z","updated":"2021-01-18T14:11:21.768Z","comments":true,"path":"2021/01/18/flask/8-1 flask高级/","link":"","permalink":"http://example.com/2021/01/18/flask/8-1%20flask%E9%AB%98%E7%BA%A7/","excerpt":"","text":"01 请求扩展 01 before_first_request ：项目启动后第一次请求的时候执行 123@app.before_first_requestdef before_first_request(): print(&#x27;第一次请求的时候执行&#x27;) 02 before_request：每次请求之前执行 1234@app.before_requestdef before_request(): print(&#x27;每次请求之前执行&#x27;) # return &#x27;直接return&#x27; # 如果有一个写了return返回值，那么其他的before_request不会执行，视图也不会执行。 注意： 可以写多个 如果有一个写了return返回值，那么其他的before_request不会执行，视图也不会执行。 03 after_request：每次请求之后执行，请求出现异常不会执行 1234def after_request(result): print(&#x27;每次请求之后执行，请求出现异常不会执行&#x27;) # 这个result是封装的响应对象，需要return否则报错 return result 04 errorhandler：可以自定义监听响应的状态码并处理： 12345678910@app.errorhandler(404)def errorhandler(error): print(error) # 是具体的错误信息 return &#x27;404页面跑到了火星上面去了&#x27;@app.errorhandler(500)def errorhandler(error): print(&#x27;errorhandler的错误信息&#x27;) print(error) return &#x27;服务器内部错误500&#x27; 05 teardown_request：每次请求之后绑定了一个函数，在非debug模式下即使遇到了异常也会执行。 123456@app.teardown_requestdef terardown_reqquest(error): print(&#x27;无论视图函数是否有错误，视图函数执行完都会执行&#x27;) print(&#x27;想要此函数生效，debug不能为True&#x27;) print(&#x27;error 是具体的错误信息&#x27;) print(error) 06 template_global()：全局模板标签 1234@app.template_global()def add(a1, a2): return a1+a2#&#123;&#123;add(1,2)&#125;&#125; 这个可以在模板中作为全局的标签使用,在模板中可以直接调用，调用方式： 1&#123;&#123;add(1,2)&#125;&#125; 07 template_filter：全局模板过滤器 123@app.template_filter()def add_filter(a1, a2, a3): return a1 + a2 + a3 这个可以在模板中作为全局过滤器使用，在模板中可以直接调用，调用方式(注意同template_global的区别) ： 1&#123;&#123;1|add_filter(2,3,4)&#125;&#125; 优势： 全局模板标签和全局模板过滤器简化了需要手动传一个函数给模板调用： 12345678910111213141516# app.py```def test(a1,a2): return a1+a2@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index.html&#x27;,test=test)```# index.html```&#123;&#123;test(22,22)&#125;&#125;``` 02 flask中间件 Flask的中间件的性质，就是可以理解为在整个请求的过程的前后定制一些个性化的功能。 flask的中间件的实现案例： 123456789101112131415161718192021222324252627282930313233343536from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): print(&#x27;视图函数中&#x27;) return &#x27;hello world&#x27;class my_middle: def __init__(self,wsgi_app): self.wsgi_app = wsgi_app def __call__(self, *args, **kwargs): print(&#x27;中间件的代码上&#x27;) obj = self.wsgi_app( *args, **kwargs) print(&#x27;中间件的代码下&#x27;) return objif __name__ == &#x27;__main__&#x27;: app.wsgi_app = my_middle(app.wsgi_app) # app.wsgi_app(environ, start_response) app.run() # 梳理一下 根据werkzeug我们可以知道 每次请求必然经历了app（） # 所以我们要查看Flask的源码找到__call__方法 # 找到了__call__方法后发现执行了return self.wsgi_app(environ, start_response) # 然后flask里面所有的内容调度都是基于这个self.wsgi_app(environ, start_response)，这就是就是flask的入口 # 如何实现中间件呢？ 原理上就是重写app.wsgi_app，然后在里面添加上一些自己想要实现的功能。 # 首先分析 app.wsgi_app需要加括号执行 所以我们把app.wsgi_app做成一个对象，并且这个对象需要加括号运行 # 也就是会触发这个对象的类的__call__()方法 # 1 那么就是app.wsgi_app=对象=自己重写的类(app.wsgi_app) ，我们需要在自己重写的类里面实现flask源码中的app.wsgi_app,在实例化的过程把原来的app.wsgi_app变成对象的属性 # 2 app.wsgi_app() =对象() = 自己重写的类.call()方法 # 3 那么上面的代码就可以理解了，在自己重写的类中实现了原有的__call__方法 梳理： 根据werkzeug我们可以知道 每次请求必然经历了app（） 所以我们要查看Flask的源码找到__call__方法 找到了Flask的__call__方法后发现执行了return self.wsgi_app(environ, start_response) flask里面所有的内容调度都是基于这个self.wsgi_app(environ, start_response)，这就是就是flask的入口，也就是selef是app，也就是app.wsgi_app（environ, start_response）为程序的入口。 如何实现中间件呢？ 原理上就是重写app.wsgi_app，然后在里面添加上一些自己想要实现的功能。 首先分析 app.wsgi_app需要加括号执行 所以我们把app.wsgi_app做成一个对象，并且这个对象需要加括号运行。 也就是会触发这个对象的类的__call__()方法。 实操理解： app.wsgi_app=对象=自己重写的类(app.wsgi_app) 提示：我们需要在自己重写的类里面实现flask源码中的app.wsgi_app,在实例化的过程把原来的 app.wsgi_app变成对象的属性 app.wsgi_app(） =对象() = 自己重写的类.call()方法 app.wsgi_app(实参） =对象(实参) = 自己重写的类.call(实参)方法 那么上面的代码就可以理解了，在自己重写的类中实现了原有的call方法，并且重新调用了原有的app.wsgi_app 03 蓝图： 3.1 蓝图的基本使用 在我的flask中，我们可以利用蓝图对程序目录的划分。 思考如果我们有很多个视图函数，比如下面这样我们是不是应该抽取出来专门的py文件进行管理呢？ 1234567891011121314151617181920212223from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/login/&#x27;)def login(): return &quot;login&quot;@app.route(&#x27;/logout/&#x27;)def logout(): return &quot;logout&quot;@app.route(&#x27;/add_order/&#x27;)def add_order(): return &quot;add_order&quot;@app.route(&#x27;modify_order&#x27;)def modify_order(): return &quot;modify_order&quot;if __name__ == &#x27;__main__&#x27;: app.run() 上面的这种是不是会显得主运行文件特别乱，这个时候我们的蓝图就闪亮登场了。 3.1.1实例： 项目目录： 123456-templates-static-views -user.py -order.py-app.py views/user.py 12345678910111213from flask import Blueprint# 1 创建蓝图user_bp = Blueprint(&#x27;user&#x27;,__name__)# 2 利用蓝图创建路由关系@user_bp.route(&#x27;/login/&#x27;)def login(): return &quot;login&quot;@user_bp.route(&#x27;/logout/&#x27;)def logout(): return &quot;logout&quot; views/order.py 1234567891011from flask import Blueprintorder_bp = Blueprint(&#x27;order&#x27;,__name__)@order_bp.route(&#x27;/add_order/&#x27;)def add_order(): return &quot;add_order&quot;@order_bp.route(&#x27;/modify_order/&#x27;)def modify_order(): return &quot;modify_order&quot; app.py 123456789101112from flask import Flaskfrom views.user import user_bpfrom views.order import order_bpapp = Flask(__name__)# 3 注册蓝图app.register_blueprint(user_bp)app.register_blueprint(order_bp)if __name__ == &#x27;__main__&#x27;: app.run() 访问： 其他的几条路由也是直接访问，在此就不做展示了。 讲解： 观察views/user.py 我们可以把所有的视图函数抽出来多个文件。 在这里我们通过user_bp = Blueprint('user',__name__)创建一个蓝图对象 参数讲解： user_bp ：是用于指向创建出的蓝图对象，可以自由命名。 Blueprint的第一个参数自定义命名的‘user’用于url_for翻转url时使用。 __name__用于寻找蓝图自定义的模板和静态文件使用。 蓝图对象的用法和之前实例化出来的app对象用法很像，可以进行注册路由。 观察app.py 这里我们需要手动的去注册一下蓝图，才会建立上url和视图函数的映射关系。 关键词： 创建蓝图 user_bp = Blueprint('user',__name__) 利用蓝图创建路由关系 @bp.route(’/login/’) def login(): return “login” 注册蓝图 app.register_blueprint(bp) 3.2 蓝图的高级使用（重点备课内容） 3.2.1 蓝图中实现path部分的url前缀 创建蓝图的时候填写url_prefix可以为增加url的path部分的前缀，可以更方便的去管理访问视图函数。 12345from flask import Blueprint# 1 创建蓝图user_bp = Blueprint(&#x27;user&#x27;,__name__,url_prefix=&#x27;/user&#x27;)# 注意斜杠跟视图函数的url连起来时候不要重复了。 注意： 斜杠跟视图函数的url连起来时候不要重复了。 图解： 2.url加前缀的时候也可以再注册蓝图的时候加上，更推荐这么做，因为代码的可读性更强。 1app.register_blueprint(user_bp,url_prefix=&#x27;/order&#x27;) 3.3.2 蓝图中自定义模板路径 创建蓝图的时候填写template_folder可以指定自定义模板路径 12# 1 创建蓝图 #所对应的参数路径是相对于蓝图文件的user_bp = Blueprint(&#x27;user&#x27;,__name__,url_prefix=&#x27;/user&#x27;,template_folder=&#x27;views_templates&#x27;) 注意： 蓝图虽然指定了自定义的模板查找路径，但是查找顺序还是会先找主app规定的模板路径(templates)，找不到再找蓝图自定义的模板路径。 Blueprint的template_folder参数指定的自定义模板路径是相对于蓝图文件的路径。 图解： (01) (02) 3.3.3 蓝图中自定义静态文件路径 创建蓝图的时候填写static_folder可以指定自定义静态文件的路径 12user_bp = Blueprint(&#x27;user&#x27;,__name__,url_prefix=&#x27;/user&#x27;,template_folder=&#x27;views_templates&#x27;, static_folder=&#x27;views_static&#x27;) 注意： 在模板中使用自定义的静态文件路径需要依赖url_for() 下节讲解如何在模板中应用蓝图自定义的静态文件。 3.3.4 url_for()翻转蓝图 视图中翻转url: 123url_for(&#x27;创建蓝图时第一个参数.蓝图下的函数名&#x27;)# 如：url_for(&#x27;user.login&#x27;) 模板中翻转url: 123&#123;&#123; url_for(&#39;创建蓝图时第一个参数.蓝图下的函数名&#39;) &#125;&#125;# 如：&#123;&#123; url_for(&#39;user.login&#39;) &#125;&#125; 模板中应用蓝图自定义路径的静态文件： 123&#123;&#123; url_for(&#39;创建蓝图时第一个参数.static&#39;,filename&#x3D;&#39;蓝图自定义静态文件路径下的文件&#39;) &#125;&#125;# 如：&#123;&#123; url_for(&#39;user.static&#39;,filename&#x3D;&#39;login.css&#39;) &#125;&#125; 3.3.5 蓝图子域名的实现 创建蓝图的时候填写subdomain可以指定子域名，可以参考之前注册路由中实现子域名。 （1） 配置C:\\Windows\\System32\\drivers\\etc\\hosts 12127.0.0.1 bookmanage.com127.0.0.1 admin.bookmanage.com **（2）**给app增加配置 1app.config[&#x27;SERVER_NAME&#x27;] = &#x27;bookmanage.com:5000&#x27; **（3）**创建蓝图的时候添加子域名 subdomain='admin' 123456789# 1 创建蓝图 user_bp = Blueprint(&#x27;user&#x27;,__name__,url_prefix=&#x27;/user&#x27;,template_folder=&#x27;views_templates&#x27;, static_folder=&#x27;views_static&#x27;,subdomain=&#x27;admin&#x27;)# 2 利用蓝图创建路由关系@user_bp.route(&#x27;/login/&#x27;)def login(): return render_template(&#x27;login_master.html&#x27;) （4） 访问admin.bookmanage.com:5000/user/login/ 3.3.6 蓝图中使用自己请求扩展 在蓝图中我们可以利用创建好的蓝图对象，设置访问蓝图的视图函数的时候触发蓝图独有的请求扩展。 例如： 12345678910order_bp = Blueprint(&#x27;order&#x27;,__name__)@order_bp.route(&#x27;/add_order/&#x27;)def add_order(): return &quot;add_order&quot;@order_bp.before_requestdef order_bp_before_request(): return &#x27;请登录&#x27; 注意： 只有访问该蓝图下的视图函数时候才会触发该蓝图的请求扩展。 可以这么理解：相当app的请求扩展是全局的，而蓝图的请求扩展是局部的只对本蓝图下的视图函数有效。 3.3 使用蓝图之中小型系统 目录结构： 1234567891011121314151617181920-flask_small_pro -app01 -__init__.py -static -templates -views -order.py -user.py -manage.py __init__.pyfrom flask import Flaskfrom app01.views.user import user_bpfrom app01.views.order import order_bpapp = Flask(__name__)app.register_blueprint(user_bp,url_prefix=&#x27;/user&#x27;)app.register_blueprint(order_bp) user.py 123456789101112from flask import Blueprintuser_bp = Blueprint(&#x27;user&#x27;,__name__)@user_bp.route(&#x27;/login/&#x27;)def login(): return &#x27;login&#x27;@user_bp.route(&#x27;/logout/&#x27;)def logout(): return &#x27;logout&#x27; order.py 123456789101112from flask import Blueprintorder_bp = Blueprint(&#x27;order&#x27;,__name__)@order_bp.route(&#x27;/add_order/&#x27;)def add_order(): return &#x27;buy_order&#x27;@order_bp.route(&#x27;/modify_order/&#x27;)def modify_order(): return &#x27;modify_order&#x27; manage.py 12345from app01 import appif __name__ == &#x27;__main__&#x27;: app.run() 3.4 使用蓝图之使用大型系统 这里所谓的大型系统并不是绝对的大型系统，而是相对规整的大型系统，相当于提供了一个参考，在真实的生成环境中会根据公司的项目以及需求，规划自己的目录结构。 文件路径： 123456789101112131415161718192021│ run.py ││└─pro_flask # 文件夹 │ __init__.py │ ├─admin # 文件夹 │ │ views.py │ │ __init__.py │ │ │ ├─static # 文件夹 │ └─templates # 文件夹 │ └─web # 文件夹 │ views.py │ __init__.py │ ├─static # 文件夹 └─templates # 文件夹 run.py 启动app 1234from pro_flask import appif __name__ == &#x27;__main__&#x27;: app.run() __init__.py 实例化核心类，导入蓝图对象，注册蓝图。 123456789from flask import Flaskfrom .admin import adminfrom .web import webapp = Flask(__name__)app.debug = Trueapp.register_blueprint(admin, url_prefix=&#x27;/admin&#x27;)app.register_blueprint(web) admin.views.py 完成注册路由以及视图函数 123456from . import admin@admin.route(&#x27;/index&#x27;)def index(): return &#x27;Admin.Index&#x27; admin.__init__.py 生成蓝图对象导入views，使得views的代码运行完成注册路由 123456789from flask import Blueprintadmin = Blueprint( &#x27;admin&#x27;, __name__, template_folder=&#x27;templates&#x27;, static_folder=&#x27;static&#x27;)from . import views web文件夹下和admin文件夹下目录构成完全一致，这里就不举例子了。","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"6 flask脚本","slug":"flask/6 flask脚本","date":"2021-01-18T11:39:27.089Z","updated":"2021-01-18T14:11:30.084Z","comments":true,"path":"2021/01/18/flask/6 flask脚本/","link":"","permalink":"http://example.com/2021/01/18/flask/6%20flask%E8%84%9A%E6%9C%AC/","excerpt":"","text":"6.1 集成Python shell 1234在实际的开发中，不免有一些任务需要在`shell`下完成。如： - 为cms后台添加超级管理员的需求， - 如迁移数据库的需求，定时任务等等，诸如这类需求更适合在shell中去操作（大部分需要在shell中去操作的都是权限比较高的任务）。 提示：迁移数据库就是用来解决数据库更新问题，解决之前我们学的db.create_all()和db.drop_all()更新数据库的时候丢失数据的问题。 flask官方提供了一个扩展组件flask-script可以实现在shell下操作我们的Flask项目。 6.1.1 flask-script的用法： 1 由于flask-script是Flask的一个扩展组件，同往常一样首先在虚拟环境中安装我们的flask_script包。 1pip install flask-script 6.1.1.1 示例：flask-script的简单实现 项目目录 12345│ manage.py│ server.py│├─static # 文件夹├─templates # 文件夹 server.py 123456789101112from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world(): return &#x27;Hello World!&#x27;if __name__ == &#x27;__main__&#x27;: app.run() manage.py 123456789101112from flask_script import Managerfrom server import appmanager = Manager(app)@manager.commanddef hello(): print(&#x27;hello world&#x27;)if __name__ == &#x27;__main__&#x27;: manager.run() 解读：manage.py （1） 从flask_script模块中导入flask_script的核心类Manager 1from flask_script import Manager （2） 从server.py模块中把app对象导入 1from server import app （3） 从Manager()类传入app对象实例化出manager对象，manager对象用于以后所有添加命令相关操作 1manager = Manager(app) **（4）**利用@manager.command装饰器添加以被装饰函数的名字命名的一条命令与被装饰函数的映射 123@manager.command # 相当于添加了一条hello命令，可以调用到hello函数def hello(): print(&#x27;hello world&#x27;) （5）manager调用run方法之前定义的命令才会生效 12if __name__ &#x3D;&#x3D; &#39;__main__&#39;: manager.run() 在shell下操作命令 在shell中切入到该manage.py的目录下，并且进入虚拟环境。输入命令python manage.py hello 1&gt;&gt;python manage.py hello 命令中的hello是@manager.command装饰器装饰的函数名 执行命令后会调用hello函数 如图所示实现了调用hello函数 6.1.1.1命令添加方式： 第一种（无参命令）： 使用manager.commad方式添加命令： 12345...@manager.commanddef demo(): print(&#x27;无参命令&#x27;)... 切入到manage.py所在的目录中，切入到虚拟环境，执行如下命令 1&gt;&gt;python manage.py demo 第二种（有参命令）: 使用manager.option('-简写的命令'，‘--全写的命令’，dest=‘传给函数的形参’)添加命令： 123456...@manager.option(&quot;-u&quot;,&quot;--username&quot;,dest=&quot;username&quot;)@manager.option(&quot;-p&quot;,&quot;--password&quot;,dest=&quot;password&quot;)def login(username, password): print(&quot;用户名:&#123;&#125; 密码: &#123;&#125;&quot;.format(username,password))... 切入到manage.py所在的目录中，切入到虚拟环境，执行如下命令. 1&gt;&gt;python manage.py login -u mark -p 123 第三种（子命令）： 比如一个功能对应着很多个命令，这个时候就可以用子命令来实现，可以将这些命令的映射单独放到一个文件方便管理。在这个放着很多命令映射的文件中实例化Manager类出一个新的对象，并在manage.py文件中通过manager.add_command(&quot;子命令&quot;,Manager对象)来添加子命令 示例： 在之前的6.1.1.1实例的项目目录中新建文件db_script.py 123456│ manage.py│ server.py│ db_script.py│├─static # 文件夹├─templates # 文件夹 db_script.py 123456789101112131415from flask_script import Managerdb_Manager = Manager()@db_Manager.commanddef init(): print(&#x27;初始迁移仓库&#x27;)@db_Manager.commanddef migrate(): print(&#x27;生成迁移脚本&#x27;)@db_Manager.commanddef upgrade(): print(&quot;迁移脚本映射到数据库&quot;) manage.py 12345678from flask_script import Managerfrom server import appfrom db_script import db_Manager # 导入子命令文件的Manager类实例化出的对象manager = Manager(app)manager.add_command(&quot;db&quot;,db_Manager) # 添加子命令... 切入到manage.py所在的目录中，切入到虚拟环境，执行如下命令. 123python manage.py db initpython manage.py db migratepython manage.py db upgrade 6.2 项目重构 6.2.1 解耦配置信息以及模型文件信息触发循环导入问题 随着项目代码的增多 我们再把连接数据库的信息放到主app文件当中会应影响我们代码的可读性，那么我们相关数据库配置的信息应该放到一个config文件当中去，像我们当时加载debug配置一样使用app.config.from_object(config)一样加载我们的数据库连接信息。 新建config.py文件,把连接数据库相关的信息放到config.py中去 然后在主app文件中加载配置信息app.config.from_object(config) config.py 1234567891011HOST = &#x27;127.0.0.1&#x27;PORT = &#x27;3306&#x27;DATABASE_NAME = &#x27;01_db&#x27;USERNAME = &#x27;root&#x27;PASSWORD = &#x27;root&#x27;DB_URI = &quot;mysql+pymysql://&#123;username&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;databasename&#125;?charset=utf8mb4&quot;\\ .format(username=USERNAME,password=PASSWORD,host=HOST,port=PORT,databasename=DATABASE_NAME)SQLALCHEMY_DATABASE_URI = DB_URISQLALCHEMY_TRACK_MODIFICATIONS = False 那么主app中的模型的文件也十分影响代码易读性，也应该新开一个modles文件夹，把我们的模型表放到modles中去 models.py 1234567from app import dbclass UserInfo(db.Model): id = db.Column(db.Integer,primary_key=True,autoincrement=True,nullable=False) name = db.Column(db.String(30),server_default=&#x27;&#x27;,comment=&quot;姓名&quot;) tel = db.Column(db.String(16),server_default=&#x27;&#x27;,comment=&quot;电话&quot; app.py 1234567891011121314151617from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyimport configfrom models import UserInfoapp = Flask(__name__)app.config.from_object(config)db = SQLAlchemy(app)@app.route(&#x27;/&#x27;)def hello_world(): return &#x27;Hello World!&#x27;if __name__ == &#x27;__main__&#x27;: app.run() 这是代码易读性提高了，但是新的问题随之出现了，出现了一个循环导入的问题。 app.py 文件导入了models，我们python中而导入文件必然会把需要导入的文件从上到下执行一遍，那么就触发了models的执行，而models执行的时候需要从app导入db，出现了一个死循环如下图，这就是python循环导入的问题。 6.2.2 重构项目解决循环导入问题 为了解耦配置信息以及模型表信息，导致了models.py和app.py出现了循环导入问题，我们的解决方案是新开启一个文件exts.py，在exts.py中生成db对象，解决循环导入问题。 实例6.2.2.1：解决循环导入问题之后重构项目 项目目录： 1234567│ app.py│ config.py│ exts.py│ models.py│├─static # 文件夹├─templates # 文件夹 config.py 1234567891011HOST = &#x27;127.0.0.1&#x27;PORT = &#x27;3306&#x27;DATABASE_NAME = &#x27;01_db&#x27;USERNAME = &#x27;root&#x27;PASSWORD = &#x27;root&#x27;DB_URI = &quot;mysql+pymysql://&#123;username&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;databasename&#125;?charset=utf8mb4&quot;\\ .format(username=USERNAME,password=PASSWORD,host=HOST,port=PORT,databasename=DATABASE_NAME)SQLALCHEMY_DATABASE_URI = DB_URISQLALCHEMY_TRACK_MODIFICATIONS = False exts.py 123from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy() models.py 123456from exts import dbclass UserInfo(db.Model): __tablename__ = &#x27;user_info&#x27; id = db.Column(db.Integer, primary_key=True, autoincrement=True) username = db.Column(db.String(20),nullable=False,server_default=&#x27;&#x27;) app.py 12345678910111213141516from flask import Flaskfrom exts import dbimport configfrom models import UserInfoapp = Flask(__name__)app.config.from_object(config)db.init_app(app)@app.route(&#x27;/&#x27;)def hello_world(): return &#x27;Hello World!&#x27;if __name__ == &#x27;__main__&#x27;: app.run() 6.3 使用Flask-Migrate迁移数据库 之前我们更新数据库的方式是先删除表然后再创建表简单粗暴，但是会丢失掉所有原来表中的数据。做web开发的我们应该深知数据无价，所以这个时候需要数据库迁移工具来完成这个工作，SQLAlcheme的开发者Michael Bayer开发了一个数据库迁移工具—Alembic来实现数据库的迁移，SQLAlchemy翻译成汉语是炼金术，而蒸馏器（Alembic）正是炼金术士最需要的工具。 我们的flask-sqlalchmy扩展组件正是基于SQLAlchemy，当然Flask也有专门做数据库迁移的扩展组件Flask-Migrate，同样Flask-Migrate正是基于Alembic。 6.3.1 Flask-Migrate的用法： 1 由于flask-migrate是Flask的一个扩展组件，同往常一样首先在虚拟环境中安装我们的flask_migrate包。 1pip install flask-migrate 为了导出数据库迁移命令，Flask-Migrate提供了一个MigrateCommand类，可附加到Flask-Script的manager对象上。在这个例子中，MigrateCommand类使用db命令附加。 我们的Flask_Migrate的操作是在shell下完成的，所以要基于Flask-script，Flask-Migrate提供了一个MigrateCommand类，需要附加到Flask-Script的manager对象上，完成命令的创建，并且Flask_Migrate同时体统了Migrate类，需要加载核心对象app和数据库对象db。完成迁移工具的配置。 示例6.3.1.1：配置Flask_Migrate 首先在实例6.2.2.1中创建manage.py manage.py代码如下 12345678910from flask_script import Managerfrom flask_migrate import Migrate,MigrateCommandfrom exts import dbfrom server import appmanager = Manager(app)Migrate(app,db)manager.add_command(&#x27;db&#x27;,MigrateCommand) 解读： （1） 首先从flask_migrate中导入 Migrate，MigrateCommand。 1from flask_migrate import Migrate,MigrateCommand （2）Migrate加载app对象和db对象获取数据库的配置信息以及模型表信息。 1Migrate(app,db) **（3）**把MigrateCommand附加到manager创建迁移数据库的子命令 1manager.add_command(&#x27;db&#x27;,MigrateCommand) 迁移脚本命令 （1） 创建迁移仓库 首先切换到项目目录下并且切入到虚拟环境中输入命令python manage.py db init 1&gt;&gt; python manage.py db init 该命令初始化我们的迁移仓库，并且在我们的项目目录中创建迁移仓库文件 （2） 创建迁移脚本 依然在我们的shell中输入命令python manage.py db migrate 1&gt;&gt; python manage.py db migrate 该命令会在数据库创建一张 alembic_version 表，存放着数据库迁移脚本的版本信息，该命令会搜集到需要迁移的模型表信息，写入到脚本中，但是并没有真正的映射到数据库中。 （3）更新数据库 依然在我们的shell中输入命令python manage.py db upgrade 1python manage.py db upgrade 对于第一次迁移来说，其作用和db.create_all()方法一样，但是在随后的迁移中，upgrade命令可以把模型表改动的部分映射到数据库中，实现了一个更新的效果，并且不影响之前保存的数据。 提示：在首次执行这个命令之前如果该数据库的库内已经有了一些表，并且这些表没有与我们的模型映射，会自动删除掉这些表。","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"5 数据库","slug":"flask/5 数据库","date":"2021-01-18T11:39:27.081Z","updated":"2021-01-18T14:11:37.037Z","comments":true,"path":"2021/01/18/flask/5 数据库/","link":"","permalink":"http://example.com/2021/01/18/flask/5%20%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"5.1 ORM 对象关系映射（英语：(Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换 。 ORM是“对象-关系-映射”的简称。在我们的web应用开发中ORM把底层的SQL数据实体转化成高层的Python对象。只需要通过Python代码即可完成数据库操作。 5.2 在Flask中应用ORM 选择ORM框架时，在我们Flask中更推荐使用Flask的扩展组件Flask-SQLchemy 。 Python实现的ORM有SQLAlchemy、Peewee、PonyORM等， 其中SQLAlchemy是Python社区使用最广泛的ORM之一，Flask-SQLchemy正是基于SQLchemy。 5.2.1 连接数据库 安装 Flask-SQLchemy 12pip install flask-sqlalchemypip install pymysql 这里我们的DBMS以mysql数据库为例， 连接数据库 示例 123456789101112131415161718from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)HOST = &#x27;127.0.0.1&#x27;PORT = &#x27;3306&#x27;DATABASE_NAME = &#x27;01_db&#x27;USERNAME = &#x27;root&#x27;PASSWORD = &#x27;root&#x27;DB_URI = &quot;mysql+pymysql://&#123;username&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;databasename&#125;?charset=utf8mb4&quot;\\.format(username=USERNAME,password=PASSWORD,host=HOST,port=PORT,databasename=DATABASE_NAME)app.config[&#x27;SQLALCHEMY_DATABASE_URI&#x27;] = DB_URIapp.config[&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;]= Falsedb = SQLAlchemy(app) 解读： 从flask_sqlalchemy模块中导入SQLAlchemy类 1from flask_sqlalchemy import SQLAlchemy app对象通过变量SQLALCHEMY_DATABASE_URI加载配置好的URI(统一资源标识符)，URI内包含了各种用于连接数据库的信息，指向一个具体的库。 常用数据库的URI格式 123456789HOST = &#x27;127.0.0.1&#x27; # ipPORT = &#x27;3306&#x27; # 端口USERNAME = &#x27;root&#x27; # 数据库账号PASSWORD = &#x27;root&#x27; # 密码DATABASE_NAME = &#x27;01_db&#x27; # 具体的一个库名DB_URI = &quot;mysql+pymysql://&#123;username&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;databasename&#125;?charset=utf8mb4&quot;\\.format(username=USERNAME,password=PASSWORD,host=HOST,port=PORT,databasename=DATABASE_NAME)app.config[&#x27;SQLALCHEMY_DATABASE_URI&#x27;] = DB_URI 3 SQLALCHEMY_TRACK_MODIFICATIONS这个配置变量决定是否追踪对象的修改，这用于FLask- SQLALchemy的事件通知系统。这个配置键默认值为None，如果没有特殊需要我们把它设置为Flase, 避免造成一些没必要的性能浪费。 1app.config[&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;]= False 4 SQLAlchemy类传入app类，引用app配置定位到具体的数据库，并且实例化出db对象，这个db对象代表我们的数据库，并且通过这个对象操作我们的ORM 1db = SQLAlchemy(app) 5.2.2 数据库模型 数据库模型： 继承了db.Model的python类，并且这个python类映射到数据库为一个表 。 每个数据库模型都对应着数据库中的一个表。 5.2.2.1 数据库模型示例 1234class UserInfo(db.Model): __tablename__ = &#x27;user_info&#x27; id = db.Column(db.Integer,primary_key=True,autoincrement=True) username = db.Column(db.String(20),nullable=False) __tablename__： 可以直接指定表名（推荐使用）。如果没有写__tablename__ 指定表名，此类名可以自动转化为表名（不推荐使用）。 类名自动转化表名的方式为User–&gt; user# 单个单词转换为小写 UserInfo–&gt; user_info# 多个单词转换为小写并使用下划线分隔 如UserInfo类在没有__tablename__指定表名时候，UserInfo类会自动映射到数据库的表名为user_info。 db.Column 类实例化表示字段（表示数据库中的列），该类实例化出的对象被一个变量接受，该变量表示字段名。该类实例化时传入的参数表示字段的约束。 如：id = db.Column(db.Integer,primary_key=True,autoincrement=True)表示该表内id字段为主键并且自动增长。 5.2.2.3 常见的字段类型表 字段 说明 映射到数据库对应类型 Integer 整数 int类型 String 字符串，String类内可选择length参数的值用于设置最大字符个数 varchar类型 Text 用于储存较长的Unicode文本，,理论上可以储存65535个字节 text类型 Date 日期，存储Python的datetime.date 对象 date类型 Time 时间，存储Python的datetime.time 对象 time类型 DateTime 时间和日期，存储Python 的datetime 对象 datetime类型 Float 浮点类型 float类型 Double 双精度浮点类型，比浮点类型小数位精度更高。 double类型，占据64位。 Boolean 布尔值 tinyint类型 Enum 枚举类型 enum类型 5.2.2.4 Column常用参数表 约束 说明 primary_key 如果设为True，该列就是表的主键 unique 如果设为True，该列每个值唯一，也就是该字段不允许出现重复值 index 如果设为True，为这列创建索引，用于提升查询效率 nullable 如果设为True，这列允许使用空值，反之则不允许使用空值。 server_default 为这列定义默认值, 默认值只支持字符串，其他类型需要db.text()方法指定 default 为这列定义默认值，但是该约束并不会真正映射到表结构中，该约束只会在ORM层面实现(不推荐使用) comment 该字段的注释 name 可以使用该参数直接指定字段名 autoincrement 设置这个字段为自动增长的。 server_default常用配置 配置默认值类型 代码 更新datatime时间 server_default = db.text(“CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP”) 当前的datatime时间 server_default = db.text(“CURRENT_TIMESTAMP”) 数字 server_default=“数字” 布尔 server_default=db.text(‘True’) / server_default=db.text(‘False’)/ server_default=‘数字’ 5.2.2.5 将写好的模型映射到数据库 123456class UserInfo(db.Model): __tablename__ = &#x27;user_info&#x27; id = db.Column(db.Integer,primary_key=True,autoincrement=True) username = db.Column(db.String(20),nullable=False) db.create_all() 如果你已经定义好了模型：一个继承db.Model的类 想把这个模型映射到数据库中（在数据库中创建这个模型所描述的一张表）：使用db.create_all()可以实现把继承了该db.model的所有模型创建到数据库中。查看数据库的时候我们会发现多了一张user_info表。 5.2.2.6 更新模型 对已存在的表的模型，使用db.create_all()无效 先db.drop_all()删除该库下的所有继承了db.model的模型表， 然后再db.create_all()使得继承了db.model的所有模型表映射到数据库中，从而创建我们更新的表。 弊端：会销毁原有的数据 解决弊端：看下一章 5.2.3 数据库操作 5.2.3.1 增 模型表 映射到数据中 12345678910class School(db.Model): __tablename__ = &quot;school&quot; id = db.Column(db.Integer,primary_key=True,nullable=False,autoincrement=True,comment=&quot;ID&quot;) name = db.Column(db.String(30),nullable=False,server_default=&#x27;&#x27;,comment=&quot;学校名称&quot;) area = db.Column(db.String(30),nullable=False,server_default=&#x27;&#x27;,comment=&quot;所属地区&quot;) score = db.Column(db.Integer,nullable=False,server_default=&#x27;600&#x27;,comment=&quot;录取分数线&quot;) def __repr__(self): return &quot;&lt;School(name:&#123;&#125;)&gt;&quot;.format(self.name)db.create_all() 示例 — 新增四条记录映射到数据库中 1234567891011school_01 =School(name=&quot;北京大学&quot;,area=&quot;北京&quot;,score=658) # 实例化模型类作为一条记录school_02 =School(name=&quot;清华大学&quot;,area=&quot;北京&quot;,score=667)school_03 =School(name=&quot;中山大学&quot;,area=&quot;广东&quot;,score=645)school_04 =School(name=&quot;复旦大学&quot;,area=&quot;上海&quot;,score=650)db.session.add(school_01) # 把新创建的记录添加到数据库会话db.session.add(school_02)db.session.add(school_03)db.session.add(school_04)db.session.commit() # 提交数据库会话 提示：数据库会话db.session和后面介绍的Flasksession对象没有关系。db.session是数据库会话也称为事务。 实例化模型类创建对象，该对象作为一条记录，实例化的过程传入的参数为字段内容。 把新创建的记录添加到数据库会话。 提交数据库会话 查看数据库 提示1 ：如果add多条记录可以使用add_all()一次添加包含多条记录的列表 如：db.session.add_all([school_01,school_02,school_03，school_04]) 5.2.3.2 查 在我们的flask中 db.session 出的对象调用query属性，可以通过query属性调用各种过滤方法完成查询。 1模型类.&lt;过滤方法&gt;.&lt;查询方法&gt; 常用过滤器表： 过滤器 说明 filter() 使用指定的规则过滤记录相当于sql的where约束条件，返回一个新查询 filter_by() 同filter原理，不同的是查询的时要使用关键字参数，返回一个新查询 limit() 使用指定的值限制原查询返回的结果的数量，返回一个新查询 offset() 偏移原查询返回的结果，返回一个新查询 order_by() 根据指定条件对原查询结构进行排序，返回一个新查询 group_by() 根据指定条件对原来查询结构进行分组，返回一个新查询 示例 下面几个查询案例需要在示例 5.2.3.1完成的基础上操作 all() 返回一个列表，列表里存放所有符合条件的记录 1234all_school = School.query.all()print(all_school) # 输出：[&lt;School(name:北京大学)&gt;, &lt;School(name:清华大学)&gt;, &lt;School(name:中山大学)&gt;, &lt;School(name:复旦大学)&gt;] **first() **返回符合条件的第一条记录： 1234school_01 =School.query.first()print(school_01)# 输出：&lt;School(name:北京大学)&gt; get() 返回指定主键值（id字段）的记录： 1234school_01 = School.query.get(1)print(school_01)#输出：&lt;School(name:北京大学)&gt; filter() 使用指定的规则过滤记录相当于 sql 的where约束条件，返回新产生的查询对象。 1234567beijing_all = School.query.filter(School.area == &quot;北京&quot;).all()beijing_first = School.query.filter(School.area == &quot;北京&quot;).first()print(beijing_all)print(beijing_first)# 输出：[&lt;School(name:北京大学)&gt;, &lt;School(name:清华大学)&gt;]# &lt;School(name:北京大学)&gt; filter_by：同filter()效果一样，查询的时候使用关键字参数查询（无法进行多表复杂查询，不推荐使用） 1234zhongshan_school = School.query.filter_by(name=&#x27;中山大学&#x27;).all()print(zhongshan_school)# 输出：[&lt;School(name:中山大学)&gt;] db.session.qury(模型类)等价于模型类.query，db.session.query功能更强大一些，可以进行多表查询。 1234567fudan_school = School.query.filter(School.name == &#x27;复旦大学&#x27;).first()print(fudan_school) # 输出：&lt;School(name:复旦大学)&gt;fudan_school = db.session.query(School).filter(School.name == &#x27;复旦大学&#x27;).first()print(fudan_school)# 输出：&lt;School(name:复旦大学)&gt; 提示：其他的过滤器会在接下来的章节具体根据实际案例讲解 5.2.3.3 改 示例 修改北京大学的录取成绩 123beida = School.query.filter(School.name==&#x27;北京大学&#x27;).first()beida.score = 630db.session.commit() 更新一条记录分为一下几部： 找到对应的记录对象 修改记录对象的属性 直接调用db.session.commit()提交会话 提示：只有要插入新的记录或要将现有的记录添加到会话中时才需要使用add（）方法。只是更新现有记录的时可以修改记录对象属性后直接提交会话 5.2.3.4 删 示例 从数据库中删除清华大学相关信息 123qinghua = School.query.filter(School.name==&#x27;清华大学&#x27;).first()db.session.delete(qinghua)db.session.commit() 删除一条记录分为以下几步： 找到对应的记录对象 需要调用delete()方法在会话中标识需要删除的记录，具体是把该记录对象传入db.session.delete(记录对象)实现标识。 调用db.session.commit()提交会话。","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"3 flask视图","slug":"flask/3 flask视图","date":"2021-01-18T11:39:27.076Z","updated":"2021-01-18T14:11:54.595Z","comments":true,"path":"2021/01/18/flask/3 flask视图/","link":"","permalink":"http://example.com/2021/01/18/flask/3%20flask%E8%A7%86%E5%9B%BE/","excerpt":"","text":"3.1 HTTP请求 3.1.1 请求报文 和 响应报文 请求报文：请求时浏览器发送的数据称为请求报文 响应报文：服务器收到了请求返回给浏览器的数据称为响应报文 报文中的GET请求 和 POST请求 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditBook?name=test1&amp;id=123456 POST方法是把提交的数据放在HTTP包的请求体中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制） POST方法提交的数据没有限制。 GET与POST请求在服务端获取请求数据方式不同。 报文示例： 12345678910111213141516171819202122232425262728293031323334&#x27;&#x27;&#x27;GET请求报文&#x27;&#x27;&#x27;# 请求首行GET / HTTP/1.1\\r\\n# get请求后面的参数GET /?name=lqz&amp;age=18 HTTP/1.1\\r\\n# 请求头Host: 127.0.0.1:8008\\r\\nConnection: keep-alive\\r\\nCache-Control: max-age=0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\nCookie: csrftoken=7xx6BxQDJ6KB0PM7qS8uTA892ACtooNbnnF4LDwlYk1Y7S7nTS81FBqwruizHsxF\\r\\n\\r\\n&#x27;# 请求体（get请求，请求体为空） &#x27;&#x27;&#x27;POST请求报文&#x27;&#x27;&#x27;# 请求首行POST /?name=lqz&amp;age=18 HTTP/1.1\\r\\n# 请求头Host: 127.0.0.1:8008\\r\\nConnection: keep-alive\\r\\nContent-Length: 21\\r\\nCache-Control: max-age=0\\r\\n Origin: http://127.0.0.1:8008\\r\\nUpgrade-Insecure-Requests: 1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36\\r\\n Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\nReferer: http://127.0.0.1:8008/?name=lqz&amp;age=18\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\nCookie: csrftoken=7xx6BxQDJ6KB0PM7qS8uTA892ACtooNbnnF4LDwlYk1Y7S7nTS81FBqwruizHsxF\\r\\n\\r\\n# 请求体name=lqz&amp;password=123&#x27; 3.1.2 request对象 request对象封装解析了请求报文中的数据，其大部分功能是由依赖包werkzeug完成的，并且每个request对象都是线程隔离的，保证了数据的安全性。 3.1.2.1 request对象常用方法 1from flask import Flask, request 3.1.2.2 使用request属性获取url ​ 访问: http://127.0.0.1:5000/student_list/?name=mark : ​ 表2-1 使用request的属性获取url 属性 解析值 属性 解析值 path u‘/student_list/’ base_url u’http://127.0.0.1:5000/student_list/’ full_path u‘/student_list/?name=mark’ url u’http://127.0.0.1:5000/student_list/?name=mark’ host u’127.0.0.1:5000’ url_root u’http://127.0.0.1:5000/’ host_url u’http://127.0.0.1:5000/’ request的解析结果如下。 1234567891011@app.route(&#x27;/student_list/&#x27;)def student_list(): print(request.path) # 输出 /student_list/ print(request.full_path) # 输出 /student_list/?name=mark print(request.host) # 输出 127.0.0.1:5000 print(request.host_url) # 输出 http://127.0.0.1:5000/ print(request.base_url) # 输出 http://127.0.0.1:5000/student_list/ print(request.url) # 输出 http://127.0.0.1:5000/student_list/?name=mark print(request.url_root) # 输出 http://127.0.0.1:5000/ return &#x27;request.urldemo测试&#x27; 3.1.2.3 其他request对象常用的属性和方法。 3.1.3 GET 和 POST： 3.1.3.1 常见的HTTP方法 请求 说明 请求 说明 GET 获取服务器资源 DELETE 删除服务器资源 POST 处理服务器资源 PATCH 在服务器更新资源（客户端提供改变的属性） PUT 在服务器更新资源（客户端提供改变后的完整资源） 一般常用的请求为GET和POST 3…1.3.2 GET请求 GET请求一般用于在服务器上获取资源，不会更改服务器的状态。 GET示例： 12345@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;]) # 不写methods也可以 默认就接收get请求def demo_get(): print(request.args.get(&#x27;name&#x27;)) # 输出 mark return &#x27;&#123;&#125;请求&#x27;.format(request.method) 注： 使用request.args属性获取get传来的参数 @app.route(’/’, methods=[‘GET’]) 指定浏览器只能以GET方法访问服务端。 3.1.3.3 POST请求： POST 请求: 会给服务器提交一些数据或者文件，会对服务器的状态产生影响。 在了解POST请求之前我们先了解一下render_termplate 3.1.3.3.1 render_template的简单使用 1from flask import Flask, request, render_template 我们暂时只简单的理解render_template模块可以把html文件返回给浏览器并渲染。 如： server.py 123456from flask import Flask, request, render_template...@app.route(&#x27;/login/&#x27;,methods=[&#x27;GET&#x27;])def login(): return render_template(&#x27;login.html&#x27;) ... 注： render_template()会去flask根目录下的templates里面寻找文件，所以给的参数路径是相对路径。 render_template()中放的文件路径是与templates文件夹相对的路径 templates/login.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/login_request/&quot; method=&quot;POST&quot;&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 注: form标签的action指定的是跳转的页面。并且会自动拼接成http://127.0.0.1:5000/login_request/ 也就是本项目的: ip地址+端口+/login_request/ form标签的method指定的是以什么方法请求服务端，此案例中请求的方法为POST方法。 访问127.0.0.1:5000/login/ 后如下图 3.1.3.3.2 POST案例： 项目目录： server.py 12345678910111213141516171819202122from flask import Flask, request, render_templateimport configapp = Flask(__name__)@app.route(&#x27;/login_request/&#x27;,methods=[&#x27;POST&#x27;])def login_request(): print(request.form.get(&#x27;username&#x27;)) # &#x27;mark&#x27; print(request.form.get(&#x27;password&#x27;)) # &#x27;123&#x27; if request.form.get(&#x27;username&#x27;) == &#x27;mark&#x27; and request.form.get(&#x27;password&#x27;) == &#x27;123&#x27;: return &#x27;success&#x27; else: return &#x27;error&#x27;@app.route(&#x27;/login/&#x27;,methods=[&#x27;GET&#x27;])def login(): return render_template(&#x27;login.html&#x27;)if __name__ == &#x27;__main__&#x27;: app.run() 注： request.form是专门用来针对表单取数据的，在这里如果前端是以表单的形式提交的，我们可以使用request.form来取值 @app.route() 中的 methods=[‘POST’] 代表只接收浏览器的POST请求 templates/login.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/login_request/&quot; method=&quot;POST&quot;&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 总体的逻辑是 : 首先访问127.0.0.1:5000/login/，默认是get请求。 然后return render_template('login.html') 返回给浏览器页面。 然后填写内容点击提交，以post方式请求 http://127.0.0.1:5000/login_request/。 然后进入def login_request()视图函数 进行逻辑判断返回成功与否。 3.1.4 一个视图函数同时可以接收GET和POST请求 我们的案例和3.3.2案例完成的业务逻辑是一样的，相当于简化了3.3.2的案例，把两个视图函数合并到一起，利用request.method属性可以获取字符串格式的请求方法。来区分本次请求是GET还是POST server.py： 123456789101112131415from flask import Flask, request, render_templateimport configapp = Flask(__name__)@app.route(&#x27;/login_inner/&#x27;,methods=[&#x27;POST&#x27;,&#x27;GET&#x27;])def login_inner(): if request.method == &#x27;GET&#x27;: #判断本次请求是否为get请求 return render_template(&#x27;login.html&#x27;) if request.form.get(&#x27;username&#x27;) == &#x27;mark&#x27; and request.form.get(&#x27;password&#x27;) == &#x27;123&#x27;: return &#x27;success&#x27; return &#x27;error&#x27;if __name__ == &#x27;__main__&#x27;: app.run(debug=True) 注： @app.route()的methods方法 指定该视图函数接收浏览器传过来的请求方法，可以指定多个。 request.method获取字符串格式的请求方法 templates/login.html： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 其展示效果 3.2 视图函数 和 视图类 3.2.1 视图函数 3.2.1.1 endpoint 别名 endpint参数是写在注册路由的装饰器中的一个参数，学名叫端点，我们可以理解为函数的别名。 原来我们翻转视图函数的url的时候是直接通过是如函数的名字，如url_for('函数名')， 现在我们可以指定一个endpoint='fbv'参数来进行翻转url。如果不指定endpoint,默认就以函数名作为端点名。 示例： 1234@app.route(&#x27;/fbvtest/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;],endpoint=&#x27;fbv&#x27;) def fbvtest(): url_demo = url_for(&#x27;fbv&#x27;) return &#x27;利用视图函数别名翻转的url为：&#123;&#125;&#x27;.format(url_demo) 注： 利用@app.route() 的endpoint='fbv'参数可以自由指定端点名，url_for可以根据指定的端点名进行翻转。 3.2.1.2 装饰器注册路由源码浅析 （1） 首先写一个小视图函数 1234567#注册装饰器的原理#1 v = app.route(&#x27;/source_code_demo/&#x27;,endpoint=&#x27;source_code&#x27;)#2 v(source_code_demo)@app.route(&#x27;/source_code_demo/&#x27;,endpoint=&#x27;source_code&#x27;)def source_code_demo(): return &#x27;source_code_demo&#x27; （2） 查看app.route()源码 12345678... def route(self, rule, **options): ... def decorator(f): endpoint = options.pop(&#x27;endpoint&#x27;, None) self.add_url_rule(rule, endpoint, f, **options) return f return decorator 解析： ，发现route()返回的是decorator函数地址，然后基于语法糖和装饰器的原理，decorator会加括号运行，像这样decorator(source_code_demo) decorator函数中首先取出endpoint，然后运行self.add_url_rule(rule, endpoint, f, **options) 所以 self.add_url_rule(rule, endpoint, f, **options)就是注册路由的核心 （3） 点进self.add_url_rule(rule, endpoint, f, **options)查看源码, 再点进_endpoint_from_view_func(view_func)查看源码 123456789101112131415161718192021 ... @setupmethoddef add_url_rule(self, rule, endpoint=None, view_func=None, provide_automatic_options=None, **options): ... if endpoint is None: endpoint = _endpoint_from_view_func(view_func) options[&#x27;endpoint&#x27;] = endpoint methods = options.pop(&#x27;methods&#x27;, None) # if the methods are not given and the view_func object knows its # methods we can use that instead. If neither exists, we go with # a tuple of only ``GET`` as default. if methods is None: methods = getattr(view_func, &#x27;methods&#x27;, None) or (&#x27;GET&#x27;,) ... 1234567def _endpoint_from_view_func(view_func): &quot;&quot;&quot;Internal helper that returns the default endpoint for a given function. This always is the function name. &quot;&quot;&quot; assert view_func is not None, &#x27;expected view func if endpoint &#x27; \\ &#x27;is not provided.&#x27; return view_func.__name__ 解析： 由上述代码我们可以直到如果没有指定endpoint，我们调用了 _endpoint_from_view_func（） 观察_endpoint_from_view_func函数我们可以知道，返回了视图函数的名字给了endpoint赋值 methos没有指定会给methos赋默认值('GET',) 小结： self.add_url_rule(rule, endpoint, f, options)就是注册路由的核心 观察_endpoint_from_view_func函数我们可以知道，返回了视图函数的名字给了endpoint赋值 methos没有指定会给methods赋默认值('GET',) 3.2.1.3 另一种注册路由的方式 —— app.add_url_rule() 通过看上一个小节写的源码，现在我们知道了app.route() 的核心就是self.add_url_rule(rule, endpoint, f, options)就是注册路由的核心。所以我们可以直接使用app.add_url_rule()的方式来注册路由。 示例： 12345def add_url_test(): return &#x27;实现了add_url方式注册路由&#x27; # url 端点 函数地址app.add_url_rule(&#x27;/add_url_test/&#x27;,endpoint=&#x27;add_demo&#x27;,view_func=add_url_test) 3.2.1.4 视图函数中添加自定义装饰器 我们在平时的开发的过程中，很多需要权限验证的功能需要用到装饰器，下面的代码是如何在flask中实现一个装饰器。 123456789101112131415161718192021222324from flask import Flask, requestfrom functools import wrapsapp = Flask(__name__)def login_verify(func): @wraps(func) def wrapper(*args, **kwargs): user_name = request.args.get(&#x27;user&#x27;) password = request.args.get(&#x27;password&#x27;) if user_name == &#x27;mark&#x27; and password == &#x27;123&#x27;: return func(*args,**kwargs) else: return &#x27;请登录&#x27; return wrapper@app.route(&#x27;/&#x27;)def hello_world(): return &#x27;Hello World!&#x27;@app.route(&#x27;/my_info/&#x27;)@login_verifydef my_info(): return &#x27;个人信息页面&#x27; 注： 装饰器一定要写在注册路由的下面，写在视图函数的上面。 装饰器内部一定要使用@wraps(func)方法，用于保护被装饰函数的属性。 它能保留原有函数的名称和docstring 3.2.2 视图类 3.2.2.1 视图类的基本写法 123456789101112131415161718192021222324252627from flask import Flask, views, request, url_forfrom functools import wrapsdef login_verify(func): @wraps(func) def wrapper(*args, **kwargs): user_name = request.args.get(&#x27;user&#x27;) password = request.args.get(&#x27;password&#x27;) if user_name == &#x27;mark&#x27; and password == &#x27;123&#x27;: return func(*args,**kwargs) else: return &#x27;请登录&#x27; return wrapperclass CBVTest(views.MethodView): methods = [&#x27;GET&#x27;,&#x27;POST&#x27;] # 指定可以接收的方法有什么,可传list(),set()类型 decorators = [login_verify,] # 指定自定义的装饰器 def get(self): print(url_for(&#x27;cbvtest&#x27;)) return &#x27;cbv_get&#x27; def post(self): return &#x27;cbv_post&#x27; app.add_url_rule(&#x27;/cbvtest&#x27;,view_func=CBVTest.as_view(name=&#x27;cbvtest&#x27;),endpoint=None) 讲解： 首先从flask中导入 views 写一个类一定要继承 views.MethodView 在类中写methods = ['GET','POST'] 可以指定可接受的请求类型 在类中写decorators = [login_verify,]可以指定装饰器，第一个装饰器是最里层函数依次往后包裹 在类中写def get(self):用于获取get请求 在类中写def post(self):用于获取post请求 添加路由的方法使用 1app.add_url_rule(&#x27;路由&#x27;,view_func=CBVTest.as_view(name=&#x27;自定义一个端点名字&#x27;)) 其原理是CBVTest.as_view(name='自定义一个端点名字')会返回一个函数，name是为这个函数命的名字，可以通过这个函数进行分发请求等操作。 3.2.3 详解注册路由的参数 常用的参数 123456@app.route和app.add_url_rule参数: rule, URL规则view_func, 视图函数名称endpoint = None, 名称，用于反向生成URL，即： url_for(&#x27;名称&#x27;)methods = None, 允许的请求方式，如：[&quot;GET&quot;, &quot;POST&quot;] 不常用的参数 （1） 对URL最后的 / 符号是否严格要求 strict_slashes = False 1234567strict_slashes = False &#x27;&#x27;&#x27; @app.route(&#x27;/index&#x27;, strict_slashes=False) #访问http://www.xx.com/index/ 或http://www.xx.com/index均可 @app.route(&#x27;/index&#x27;, strict_slashes=True) #仅访问http://www.xx.com/index &#x27;&#x27;&#x27; （2） 重定向到指定地址redirect_to=“ ” 123456789@app.route(&quot;/&quot;,redirect_to=&#x27;/home/&#x27;)def index(): return &#x27;根路径&#x27;@app.route(&quot;/home/&quot;)def admin_demo(): return &#x27;home路径&#x27; （3） 为函数提供默认参数值 1defaults = None, 默认值, 当URL中无参数，函数需要参数时，使用defaults = &#123;&#x27;k&#x27;: &#x27;v&#x27;&#125; **（4）**子域名设置subdomain=“ ” 12345678910111213141516171819202122232425262728293031323334353637from flask import Flask,url_forapp = Flask(__name__)app.debug = True&#x27;&#x27;&#x27;先在hosts设置域名解析(就是在本机的hosts文件上编辑上域名对应ip的关系) 域名解析会先解析本地如果没有再解析dns服务器C:\\Windows\\System32\\drivers\\etc\\hosts127.0.0.1 mark.com127.0.0.1 admin.mark.com&#x27;&#x27;&#x27;app.config[&#x27;SERVER_NAME&#x27;] = &#x27;mark.com:5000&#x27; # 这个代表访问这个域名的时候要访问5000端口@app.route(&quot;/&quot;)def index(): return &#x27;设置域名成功&#x27;@app.route(&quot;/admin_demo/&quot;,subdomain=&#x27;admin&#x27;)def admin_demo(): return &#x27;设置子域名成功&#x27;&#x27;&#x27;&#x27;在浏览器中访问主域名mark.com:5000/在浏览器中访问子域名admin.mark.com:5000/admin_demo/注意：后面跟的path路径部分正常写&#x27;&#x27;&#x27;if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;127.0.0.1&#x27;,port=5000) # 测试服务器不稳定，尽量手动制定ip和端口","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"2 flask注册路由","slug":"flask/2 flask注册路由","date":"2021-01-18T11:39:27.072Z","updated":"2021-01-18T14:12:01.014Z","comments":true,"path":"2021/01/18/flask/2 flask注册路由/","link":"","permalink":"http://example.com/2021/01/18/flask/2%20flask%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1/","excerpt":"","text":"2.1 URL的组成 12scheme:// host:port/ path/ ?parameter=xxx#anchorhttps:// www.baidu.com/ Public/linux/ ?fr=aladdin#23 scheme：代表的是访问的协议，一般为http或者https以及ftp等。 host：主机名，域名，比如www.baidu.com。 port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。 path：路径。比如：www.baidu.com/Public/linux/?python=aladdin#23，www.baidu.com后面的Public/linux就是path。 query-string：查询字符串，比如：www.baidu.com/s?wd=python，？后面的python=aladdin就是查询字符串。 anchor：锚点，后台一般不用管，前端用来做页面定位的。比如：https://www.oldboyedu.com/Public/linux/?fr=aladdin#23 ,#后面的23就是锚点 2.2 URL与路由的区别 路由是根据url定位到具体的pyhon类或python函数的程序，这段程序我们称之为路由。 在Flask程序中使用路由我们称之为注册路由，是使用程序实例提供的app.route（）装饰器注册路由，而括号内的字符串就是url，注册路由的过程就是完成了 url和python类或函数映射的过程，可以理解为会有一张表保存了url与python类或函数的对应关系。 123@app.route(&#x27;/&#x27;)def hello_world(): return &#x27;Hello World!&#x27; 2.3 url传参的两种 2.3.1 动态路由传参 URL中包含可变的部分，如： ​ 根据学生的id找到具体的学生，http://127.0.0.1:5000/student_list/&lt;student_id&gt;/ 代码示例： 123@app.route(&#x27;/student_list/&lt;student_id&gt;/&#x27;)def student_list(student_id): return &#x27;学生&#123;&#125;号的信息&#x27;.format(student_id) 2.3.1.1 动态路由过滤** 可以对参数限定数据类型，比如上面的文章详情，限定student_id必须为整数类型 123@app.route(&#x27;/student_list/&lt;int:student_id&gt;/&#x27;)def article_detail(student_id): return &#x27;学生&#123;&#125;号的信息&#x27;.format(student_id) 主要有这几种类型过滤： string: 默认的数据类型，接收没有任何斜杠&quot;\\ /&quot;的字符串 int: 整型 float: 浮点型 path: 和string类型相似，但是接受斜杠，如：可以接受参数/aa/bb/cc/多条放在一起 uuid: 只接受uuid格式的字符串字符串， 注：uuid为全宇宙唯一的串 any: 可以指定多种路径 ​ url_path的变量名是自己定义的，可选：student，class 12345678# 可访问 127.0.0.1/student/1/ 或 127.0.0.1/class/1/ @app.route(&#x27;/&lt;any(student,class):url_path&gt;/&lt;id&gt;/&#x27;)def item(url_path, id): if url_path == &#x27;student&#x27;: return &#x27;学生&#123;&#125;详情&#x27;.format(id) else: return &#x27;班级&#123;&#125;详情&#x27;.format(id) 2.3.2 查询字符串传参 查询字符串： 如www.baidu.com/s?wd=python&amp;ad=flask的参数， ？ 后的key=value便是查询字符串， 可以写多个key=value用&amp;相连 从flask模块里面导入request对象，用request.args属性在我们的程序中根据查询字符串的key取出查询字符串的value。 代码示例： 12345678910# 请求url: 127.0.0.1:5000/student_name/?name=mark&amp;age=18from flask import Flask,request...@app.route(&#x27;/student_name/&#x27;)def school_name_list(): name = request.args.get(&#x27;name&#x27;) age = request.args.get(&#x27;age&#x27;) return &quot;学生的姓名为&#123;&#125;，年龄为&#123;&#125;&quot;.format(name, age) 2.4 url_for的使用 2.4.1 url_for()的作用： url的反向查询 应对：即便改动url，也能追踪到改URL 2.4.2 url_for()的原理： 利用视图函数名字一般不会改变的特性，利用视图函数的名字去动态精准的获取url，以便于开发使用。 1url_for(&#x27;视图函数名字&#x27;) # 输出该视图函数url 代码示例： 1234567891011121314151617from flask import Flask, url_forapp = Flask(__name__)app.config.update(DEBUG=True)@app.route(&#x27;/&#x27;)def demo1(): print(url_for(&quot;book&quot;)) # 注意这个引用的是视图函数的名字 为字符串格式 print(type(url_for(&quot;book&quot;))) return url_for(&quot;book&quot;)@app.route(&#x27;/book_list/&#x27;)def book(): return &#x27;flask_book&#x27;if __name__ == &quot;__main__&quot;: app.run() 2.4.3 url_for 处理动态的视图函数（动态路由） 想获取动态路由，必须以关键字实参的形式 为动态的path部分赋值，注意动态的path部分必须被赋值 123456789@app.route(&#x27;/demo2/&#x27;)def demo2(): student_url = url_for(&#x27;student&#x27;, id=5, name=&#x27;mark&#x27;) # id 就是动态path的key 必须赋值，# name 将作为查询字符串传入 print(student_url) return student_url@app.route(&#x27;/student/&lt;int:id&gt;/&#x27;)def student(id): return &#x27;student &#123;&#125;&#x27;.format(id) 12# 控制台输出：/student/5/?name=mark 2.4.4 url_for为url添加查询字符串 想在路径后面拼出来查询字符串，以关键字实参的形式放到url_for()里面作为参数，会自动拼成路径 12345678910@app.route(&#x27;/demo3/&#x27;)def demo3(): school_url = url_for(&#x27;school&#x27;, school_level=&#x27;high&#x27;, name=&#x27;college&#x27;) # 具体要拼接的查询参数 以关键字实参的形式写在url_for里 print(school_url) return school_url@app.route(&#x27;/school/&#x27;)def school(): return &#x27;school message&#x27; 12# 控制台输出：/school/?school_level=high&amp;name=college 2.4.5 自定义动态路由过滤器之正则匹配 通过继承werkzeug.routing 的BaseConverter类从而自己定义一个动态路由过滤器的规则 12345678910111213141516171819from flask import Flask,requestfrom werkzeug.routing import BaseConverterapp = Flask(__name__)app.debug =Trueclass TelephoneConverter(BaseConverter): regex = &#x27;1[3857]\\d&#123;9&#125;&#x27; #右下斜杠dapp.url_map.converters[&#x27;tel&#x27;] = TelephoneConverter@app.route(&#x27;/student/&lt;tel:telenum&gt;/&#x27;)def student_detail(telenum): return &#x27;学生的手机号码是&#123;&#125;&#x27;.format(telenum)if __name__ == &#x27;__main__&#x27;: app.run() 注： 自定义动态路由过滤器类，该类必须继承werkzeug.routing 的BaseConverter类 通过regex属性指定路由规则 讲自定义的类映射到app.url_map.converters中（其本质是一个字典） app.url_map.converters['tel'] = TelephoneConverter app.url_map下的默认的路由规则 12345678910#: the default converter mapping for the map.DEFAULT_CONVERTERS = &#123; &quot;default&quot;: UnicodeConverter, &quot;string&quot;: UnicodeConverter, &quot;any&quot;: AnyConverter, &quot;path&quot;: PathConverter, &quot;int&quot;: IntegerConverter, &quot;float&quot;: FloatConverter, &quot;uuid&quot;: UUIDConverter,&#125; 2.4.5.1 自定义动态路由过滤器之处理动态路由 自定义一个类，该通过继承werkzeug.routing 的BaseConverter类不光可以实现正则匹配，我们介绍一下以下两个方法： 在该类中实现 to_python 方法： 这个方法的返回值，将会传递给视图函数的形参。我们可以利用这个方法实现处理url中动态路由部分。 在该类中实现 to_url 方法： 翻转url的时候也就是使用url_for函数的时候，我们传入指定的动态路由部分，触发to_url方法，这个方法的返回值，会拼接在非动态路由上，从而实现生成符合要求的url格式。 代码示例： 123456789101112131415161718192021222324252627282930313233from flask import Flask,request,url_forfrom werkzeug.routing import BaseConverterapp = Flask(__name__)app.debug =Trueclass ListConverter(BaseConverter): regex = &#x27;.*&#x27; # 这个regex代表都匹配的意思，可以根据自己的需求制定url规则 def to_python(self, value): &#x27;&#x27;&#x27;这个函数用于拿到了路由里的动态参数赋值给value， 可以在to_python进行操作动态参数， 返回操作完的的结果给视图函数的形参&#x27;&#x27;&#x27; return value.split(&#x27;+&#x27;) def to_url(self, value): &#x27;&#x27;&#x27;这个函数用于和url_for连用， url_for通过指定给动态参数(以关键字实参的形式)赋值给value 我们可以根据我们的需求操作url_for传进来的参数， 然后返回一个理想的动态路由内容拼接在url上&#x27;&#x27;&#x27; return &#x27;+&#x27;.join(value)app.url_map.converters[&#x27;list&#x27;] = ListConverter@app.route(&#x27;/student_list/&lt;list:students&gt;/&#x27;)def student_list(students): print(url_for(&#x27;student_list&#x27;,students=[&#x27;a&#x27;,&#x27;b&#x27;])) # 输出 /student_list/a+b/ return &#x27;&#123;&#125;&#x27;.format(students)if __name__ == &#x27;__main__&#x27;: app.run() 证明to_python()方法把访问时候动态路由部分被处理成列表了。 证明我们的 to_url() 方法把url_for()函数传入的动态路由部分由列表转换成拼接字符串了。","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"1 初识flask","slug":"flask/1 初识flask","date":"2021-01-18T11:39:27.067Z","updated":"2021-01-18T14:12:08.711Z","comments":true,"path":"2021/01/18/flask/1 初识flask/","link":"","permalink":"http://example.com/2021/01/18/flask/1%20%E5%88%9D%E8%AF%86flask/","excerpt":"","text":"参考：小猿取经 视频：五天从入门到熟练flask框架 flask性能上基本满足一般web开发的需求, 并且灵活性以及可扩展性上要优于其他web框架, 对各种数据库的契合度都非常高 关键词： 性能基本满足需求 灵活性可拓展性强 对各种数据库的契合度都比较高。 在真实的生产环境下，小项目开发快，大项目设计灵活 1 在虚拟环境中安装Flask模块 1pip install flask 从上面成功安装的输出内容可以看出，除了Flask包外，同时被安装的还有5个依赖包，它们的主要介绍如表（1-1）所示。 包名及版本 功能 Jinja2-2.10 渲染模板引擎工具集 MarkupSafe-1.1.0 可以识别HTML转义规则。HTML字符转义工具集 Werkzeug-0.14.1 Web 框架的底层库，提供了请求及响应以及开发服务器的功能，简称WSGI工具集 click-7.0 命令行工具集 itsdangerous-1.1.0 加密工具集 2 开始第一个Flask程序 2.1 项目目录 “static文件夹”用于存放各种静态文件 css、js、图片等等 “templates文件夹”用于存放html模板文件 “app.py”为我们的主文件 ，启动项目需要启动该文件 2.2 app.py 代码解读 123456789101112# app.pyfrom flask import Flaskapp = Flask(__name__) # 实例化这个Flask类的到一个实例化对象app； __name__变量指代 当前py文件@app.route(&#x27;/&#x27;) # 以装饰器实现 —— 匹配urldef hello_world(): # 视图函数 return &#x27;Hello World!&#x27;if __name__ == &#x27;__main__&#x27;: # 保证代码只用于开发环境 app.run() # 内部定义了默认的 ip+端口为127.0.0.1:5000，并且调用了werkzeug.serving为我们创建了一个开发服务器（由依赖包Werkzeug提供） app.run()底层代码 123456789101112131415161718def run(self, host=None, port=None, debug=None, load_dotenv=True, **options): ... _host =&#x27;127.0.0.1&#x27; _port = 5000 ... host = host or sn_host or _host port = int(port or sn_port or _port) ... from werkzeug.serving import run_simple try: run_simple(host, port, self, **options) finally: # reset the first request information if the development server # reset normally. This makes it possible to restart the server # without reloader and that stuff from an interactive shell. self._got_first_request = False 2.2.1 Werkzeug简介 Werkzeug是一个WSGI工具包，他可以作为一个Web框架的底层库。内部封装了例如 Request，Response 等等 。 flask基于Werkzeug,flask只保留了web开发的核心功能。 代码示例： 12345678910from werkzeug.wrappers import Request, Response@Request.applicationdef hello(request): return Response(&#x27;Hello World!&#x27;)if __name__ == &#x27;__main__&#x27;: from werkzeug.serving import run_simple run_simple(&#x27;localhost&#x27;, 4000, hello) 原理： 1 app.run() 调用 werkzeug.serving的run_simple(host, port, self, **options) 2 self()等价于app(), app()调用Flask类的__call__方法 3 Flask类的__call__方法返回了 self.wsgi_app(environ, start_response) 4 flask程序的执行过程都在 self.wsgi_app(environ, start_response)中 具体代码如下： 123456789101112131415161718192021222324def run(self, host=None, port=None, debug=None, load_dotenv=True, **options): ... _host =&#x27;127.0.0.1&#x27; _port = 5000 ... host = host or sn_host or _host port = int(port or sn_port or _port) ... from werkzeug.serving import run_simple try: run_simple(host, port, self, **options) finally: # reset the first request information if the development server # reset normally. This makes it possible to restart the server # without reloader and that stuff from an interactive shell. self._got_first_request = False 1234567891011121314151617181920212223242526272829... def __call__(self, environ, start_response): &quot;&quot;&quot;The WSGI server calls the Flask application object as the WSGI application. This calls :meth:`wsgi_app` which can be wrapped to applying middleware.&quot;&quot;&quot; return self.wsgi_app(environ, start_response) ... def wsgi_app(self, environ, start_response): ctx = self.request_context(environ) error = None try: try: ctx.push() response = self.full_dispatch_request() except Exception as e: error = e response = self.handle_exception(e) except: error = sys.exc_info()[1] raise return response(environ, start_response) finally: if self.should_ignore_error(error): error = None ctx.auto_pop(error) ... 2.2.2 运行项目 在app.py中右键run启动项目 浏览器访问：http://127.0.0.1:5000 2.2.3 DEBUG模式 DEBUG模式解决了两个问题。 flask代码中如果出现了异常，我们在浏览器中不会提示具体的错误信息，开启debug模式后会把具体的错误信息发送到浏览器上。 flask代码如果被修改了，必须要重启项目修改的代码才会有效，开启debug模式后我们修改了代码只要ctrl+s我们的flask项目就会自动重新加载，不需要手动加载整个网站。 代码示例： 123456789101112from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello(): a = [1,2,3,4] print(a[4]) return &quot;hello&quot;if __name__ == &#x27;__main__&#x27;: app.run(debug=True) # 开启debug模式 四种开启DEBUG的方式 第一种 1234567891011from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello(): a = [1,2,3,4] print(a[4]) return &quot;hello&quot;if __name__ == &#x27;__main__&#x27;: app.run(debug=True) # 设置 第二种 123456789101112from flask import Flaskapp = Flask(__name__)app.debug = True # 设置@app.route(&#x27;/&#x27;)def hello(): a = [1,2,3,4] print(a[4]) return &quot;hello&quot;if __name__ == &#x27;__main__&#x27;: app.run() 第三种 123456789101112from flask import Flaskapp = Flask(__name__)app.config.update(DEBUG=True) # 设置@app.route(&#x27;/&#x27;)def hello(): a = [1,2,3,4] print(a[4]) return &quot;hello&quot;if __name__ == &#x27;__main__&#x27;: app.run() 第四种 需要在app.py所在的目录里 再创建一个config.py，随着我们的学习会越来越多的用到这个配置文件，来配置我们的flask项目，注意配置的信息一般为大写。 config.py 1DEBUG = True app.py 1234567891011121314from flask import Flaskimport config # 导入app = Flask(__name__)app.config.from_object(config) # 设置@app.route(&#x27;/&#x27;)def hello(): a = [1,2,3,4] print(a[4]) return &quot;hello&quot;if __name__ == &#x27;__main__&#x27;: app.run() 注： app.config 本质上继承的字典，是字典的子类的一个对象","categories":[{"name":"python框架","slug":"python框架","permalink":"http://example.com/categories/python%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-18T10:38:44.606Z","updated":"2021-01-18T10:38:44.607Z","comments":true,"path":"2021/01/18/hello-world/","link":"","permalink":"http://example.com/2021/01/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"4 模板","slug":"flask/4 模板","date":"2021-01-18T09:01:48.499Z","updated":"2021-01-18T14:31:54.102Z","comments":true,"path":"2021/01/18/flask/4 模板/","link":"","permalink":"http://example.com/2021/01/18/flask/4%20%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"4.1 重定向 4.1.1 两种重定向 http状态码 应用场景 优势 暂时性重定向 302 访问一些需要权限的页面，会自动重定向到权限认证的页面 重定向在设计上会提升用户体验 永久性重定向 301 废弃原有的网址被访问，会自动重定向到新的网址确保用户访问成功 重定向在设计上会提升用户体验，有利于搜索引擎优化 4.1.2 使用重定向 1from flask import Flask,redirect 4.1.2.1 暂时性重定向 12345678910111213141516from flask import Flask,redirect@app.route(&#x27;/user_info/&#x27;)def user_info(): name = request.args.get(&#x27;name&#x27;) pwd = request.args.get(&#x27;pwd&#x27;) if name==&#x27;mark&#x27; and pwd == &#x27;123&#x27;: return &#x27;&#123;&#125;的信息&#x27;.format(name) return redirect(&#x27;/login/&#x27;) # 可以换成 return redirect(url_for(&#x27;login&#x27;))@app.route(&#x27;/login/&#x27;)def login(): return &#x27;这是登录页面&#x27;... 没有通过权限验证的情况 通过权限验证的情况 4.1.2.2 永久性重定向 123456789101112131415from flask import Flask,redirect...@app.route(&#x27;/user_info/&#x27;)def user_info(): name = request.args.get(&#x27;name&#x27;) pwd = request.args.get(&#x27;pwd&#x27;) if name==&#x27;mark&#x27; and pwd == &#x27;123&#x27;: return &#x27;&#123;&#125;的信息&#x27;.format(name) return redirect(&#x27;/login/&#x27;, code=301) # 会返回301状态码给浏览器 @app.route(&#x27;/login/&#x27;)def login(): return &#x27;这是登录页面&#x27;... 注：永久性重定向只给redirect('/login/', code=301)多加了个code=301参数 4.2 jinja2引擎模板 4.2.1 在Flask如何使用模板引擎？ Flask使用jinja2作为框架的默认模板引擎，Jinja2是基于python的模板引擎，功能比较类似于于PHP的smarty，J2ee的Freemarker和velocity。Jinja2除了设置变量，还允许我们在模板中添加if判断，执行for迭代，调用函数等，以各种方式控制模板的输出。并且jinja2不限制模板的格式为html，可以是任何格式的文本文件。 4.2.1.1 模板引擎返回对比视图函数直接返回html代码 项目目录 项目代码 **（1）login01.html ** 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;login01&lt;/h1&gt; &lt;!--login02.html文件的这一行的内容是：‘ &lt;h1&gt;login02&lt;/h1&gt; ’ --&gt;&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; (2)login02.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;login01&lt;/h1&gt; &lt;!--login02.html文件的这一行的内容是：‘ &lt;h1&gt;login02&lt;/h1&gt; ’ --&gt;&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; (3) server.py 1234567891011121314151617181920212223242526272829303132333435363738394041from flask import Flask, render_templateimport configapp = Flask(__name__)app.config.from_object(config)@app.route(&#x27;/demo/&#x27;)def demo(): return &#x27;&lt;h2&gt;手写html&lt;/h2&gt;&#x27;@app.route(&#x27;/demo02/&#x27;)def demo02(): return &#x27;&#x27;&#x27;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--&lt;form action=&quot;/login_request/&quot; method=&quot;POST&quot;&gt;--&gt;&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&#x27;&#x27;&#x27;@app.route(&#x27;/demo03/&#x27;)def demo03(): return render_template(&#x27;login01.html&#x27;)@app.route(&#x27;/demo04/&#x27;)def demo04(): return render_template(&#x27;box/login02.html&#x27;)if __name__ == &#x27;__main__&#x27;: app.run() server.py代码逻辑分析： demo函数 和 demo02函数证明直接返回html代码可渲染浏览器 demo03 证明利用模板引擎 实现了业务逻辑和页面逻辑的分离，减轻了开发的复杂度 demo04 证明了 render_template('box/login02.html')的路径是templates文件夹的相对路径 4.2.1.2 修改默认模板引擎寻求路径 Flask类中的template_folder参数可以指定模板寻找路径 基于上2.3.1的项目 现在把templates中的文件复制到 C:/Users/Administrator/Desktop/template_box中，并且删除项目中的templates的文件。 修改server.py中app = Flask(__name__)为app = Flask(__name__,template_folder='C:/Users/Administrator/Desktop/template_box') 分析: 渲染一切正常 说明Flask类中的template_folder参数可以指定模板寻找路径。 4.2.1.3 模板引擎传参 我们之前提到过，模板引擎还可以读取并执行模板中的特殊语法标记，并根据传入的数据将变量替换为实际值，这个步骤我们就称之为模板引擎传参。 我们传参的时候要应用render_template()利用render_template的第二个参数进行传参，该函数在定义时候，第二个参数是可变长形参，所以在传值的时候我们可以传入多个关键字实参。 在模板中接收的时候使用&#123;&#123;&#125;&#125;`包裹参数进行接收。 ![](https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191009224222394-1528143259.jpg) ###### 示例1（第一种传参方式）： * **目录结构** 1234│ server.py│└─templates # 文件夹 index.html * **server.py** 1234@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index.html&#x27;,name=&quot;mark&quot;,age=18) * **index.html** 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模板传参&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;&#123;name&#125;&#125; &#123;&#123;age&#125;&#125;&lt;/body&gt;&lt;/html&gt; ![](https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191009224255518-247003677.png) ###### 示例2（第二种传参方式）： * **目录结构**：同上 * **server.py** 1234567@app.route(&#x27;/demo1/&#x27;)def demo1(): context_dict = &#123;&quot;name&quot;:&quot;mark&quot;, &quot;age&quot;:&quot;mark&quot;, &quot;sex&quot;:&quot;girl&quot;&#125; return render_template(&#x27;index.html&#x27;,context_dict = context_dict) * **index.html** 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模板传参&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;&#123;context_dict.name&#125;&#125; &#123;&#123;context_dict.age&#125;&#125; &#123;&#123;context_dict.sex&#125;&#125;&lt;/body&gt;&lt;/html&gt; ![](https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191009224349511-583920666.png) ###### 示例3（第三种传参方式）： * **目录结构**：同上 * **server.py** 12345678def demo2(): context_dict = &#123;&quot;name&quot;: &quot;mark&quot;, &quot;age&quot;: &quot;mark&quot;, &quot;sex&quot;: &quot;girl&quot;, &quot;other_info&quot;:&#123;&quot;tel&quot;:1365, &quot;qq&quot;:565656&#125;&#125; return render_template(&#x27;index.html&#x27;,**context_dict) * **index.html** 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模板传参&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;&#123;name&#125;&#125; &#123;&#123;age&#125;&#125; &#123;&#123;sex&#125;&#125; &#123;&#123;other_info.tel&#125;&#125; &#123;&#123;other_info[&quot;qq&quot;]&#125;&#125;&lt;/body&gt;&lt;/html&gt; ![](https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191009224455972-1435542843.png) **注**： 在视图函数中 - render_template传参的时候以关键字实参进行传参。可以传多个，可以用**讲字典打散成关键字实参。 在模板中 - jinja2模板引擎支持接收变量在用 `&#123;&#123;&#125;&#125;包裹参数进行接收 并且如果发现是字典，可以用.字典里面的key取出value值。也可以直接字典跟[]进行取值。 4.2.1.4 模板中使用url_for() 在模板中如果有使用url的需求，我们可以直接手写一个url，也可以使用&#123;&#123; url_for('视图函数名') &#125;动态翻转一个url。 示例： 项目目录： 12345│ server.py│└─templates # 文件夹 index.html info.html server.py 123456789101112...@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index.html&#x27;, name=&quot;mark&quot;, age=18)@app.route(&#x27;/info/&#x27;)def info(): return render_template(&#x27;info.html&#x27;)... info.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;信息页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是信息页面&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模板传参&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;/info/&quot;&gt;正常跳转&lt;/a&gt; &lt;a href=&quot;&#123;&#123; url_for(&#x27;info&#x27;) &#125;&#125;&quot;&gt;urlfor跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 正常跳转 和 urlfor跳转，皆可以实现跳转到info.html页面。 正常跳转就不做演示了 注： url_for 在视图函数中如何使用，在模板中同样的用法。 支持翻转查询字符串 支持动态路由翻转 4.2.1.5 jinjia2中控制语句 在jinja2中用&#123;% %&#125;特殊符号来编辑控制语句，一个语句以&#123;% ... %&#125;`为起始 并且以`&#123;% end... %&#125;来标记结束。 1 jinja2中逻辑语句/if语句 可以使用&gt; , &lt; , &lt;=, ==，!=,进行判断， 也可以使用 and，or，not，（）来进行逻辑合并 1234567&#123;% if age &gt; 18 %&#125; &lt;p&gt;成年人&lt;&#x2F;p&gt;&#123;% elif age &#x3D;&#x3D; 18 %&#125; &lt;p&gt;刚刚成年&lt;&#x2F;p&gt;&#123;% else %&#125; &lt;p&gt;未成年&lt;&#x2F;p&gt;&#123;% endif %&#125; 注意：``只是为了渲染明显 实例： 项目目录： 1234│ server.py│└─templates # 文件夹 index.html server.py 123456789...@app.route(&#x27;/&#x27;)def hello_world(): context_dict = &#123; &#x27;age&#x27;: 17, &#x27;sex&#x27;: &#x27;man&#x27;, &#125; return render_template(&#x27;index.html&#x27;,**context_dict)... index.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jinja2分支&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% if sex == &#x27;man&#x27; %&#125; &lt;p&gt;男人&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;女人&lt;/p&gt; &#123;% endif %&#125; &#123;% if age &gt; 18 %&#125; &lt;p&gt;成年人&lt;/p&gt; &#123;% elif age == 18 %&#125; &lt;p&gt;刚刚成年&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;未成年&lt;/p&gt; &#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt; 2 jinja2中循环语句/for循环 for循环可以便利任何一个可迭代对象，包括列表、字典等，支持反向遍历 列表循环： 12345&#123;% for country in countrys%&#125; &lt;p&gt;&#123;&#123; country &#125;&#125;&lt;&#x2F;p&gt;&#123;% else %&#125; &lt;p&gt;没有值&lt;&#x2F;p&gt;&#123;% endfor %&#125; 2.1 列表循环遍历项目实例： 项目目录： 1234│ server.py│└─templates # 文件夹 index.html sever.py 123456@app.route(&#x27;/&#x27;) def hello_world(): context_dict = &#123; &#x27;countrys&#x27;:[&quot;1-china&quot;,&quot;2-America&quot;,&quot;3-French&quot;] &#125; return render_template(&#x27;index.html&#x27;,**context_dict) index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;for循环&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% for country in countrys %&#125; &#123;# &#123;% for country in countrys|reverse %&#125; 可以实现反向遍历#&#125; &lt;p&gt;&#123;&#123; country &#125;&#125;&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;没有值&lt;/p&gt; &#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; 反向遍历实例 1server.py&#96;的 &#96;&#123;% for country in countrys %&#125;&#96; 改为 &#96;&#123;% for country in countrys|reverse %&#125; 可以实现反向遍历，运行效果如下图 2.2 字典循环遍历项目实例： 项目目录 1234│ server.py│└─templates # 文件夹 index.html sever.py 123456789101112131415161718192021222324252627282930@app.route(&#x27;/&#x27;) def hello_world(): context_dict = &#123; &#x27;countrys&#x27;:[&quot;1-china&quot;,&quot;2-America&quot;,&quot;3-French&quot;] &#125; return render_template(&#x27;index.html&#x27;,**context_dict) @app.route(&#x27;/demo/&#x27;) def demo(): context_dict =&#123; &#x27;colleges&#x27;:[ &#123; &#x27;name&#x27;: &#x27;清华大学&#x27;, &#x27;area&#x27;: &#x27;北京&#x27; &#125;, &#123; &#x27;name&#x27;: &#x27;复旦大学&#x27;, &#x27;area&#x27;: &#x27;上海&#x27; &#x27;&#x27; &#125;, &#123; &#x27;name&#x27;: &#x27;吉林大学&#x27;, &#x27;area&#x27;: &#x27;吉林&#x27; &#125;, &#123; &#x27;name&#x27;: &#x27;中山大学&#x27;, &#x27;area&#x27;: &#x27;广东&#x27; &#125; ] &#125; return render_template(&#x27;index.html&#x27;,**context_dict) index.html 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;for循环&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;1开始的序号&lt;/th&gt; &lt;th&gt;0开始的序号&lt;/th&gt; &lt;th&gt;大学名称&lt;/th&gt; &lt;th&gt;所属地区&lt;/th&gt; &lt;th&gt;总数&lt;/th&gt; &lt;/tr&gt; &#123;% for college in colleges %&#125; &#123;% if loop.first %&#125; &lt;tr style=&quot;background: blue&quot;&gt; &#123;% elif loop.last %&#125; &lt;tr style=&quot;background: yellow &quot;&gt; &#123;% else %&#125; &lt;tr&gt; &#123;% endif %&#125; &lt;td&gt;&#123;&#123; loop.index &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; loop.index0 &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; college.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; college.area &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; loop.length &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; for循环常用变量表 for循环常用变量 功能描述 loop.index 当前循环的索引（从1开始） loop.index0 当前循环的索引（从0开始） loop.first 是否是第一次循环，是返回True，否则返回Flase loop.last 是否是最后一次循环，是返回True，否则返回Flase loop.length 总共可以循环的次数 / 迭代器的长度 for循环中的else用法 for还可以else分支语法，如果for内部没有遍历出来内容，那么就会走else分支，反之如果for循环遍历出了内容，则不会运行else分支。 注意：jinja2中的for 和 else逻辑不通于python在此不要类比python中的 for 和 else 。 12345&#123;% for country in countrys|reverse %&#125; &lt;p&gt;&#123;&#123; country &#125;&#125;&lt;&#x2F;p&gt; &#123;% else %&#125; &lt;p&gt;没有值&lt;&#x2F;p&gt; &#123;% endfor %&#125; 4.2.1.6 模板加载静态文件 在模板中加载静态文件的时候也要使用到url_for()函数，去寻找具体的静态文件资源。第一个参数是定位到static文件夹，filename参数定位到static文件夹内的具体资源。 1&#123;&#123; url_for(&#x27;static&#x27;,filename=&#x27;相对于static文件夹的路径&#x27;) &#125;&#125; 实例： 项目目录： 1234567891011121314│ app.py│├─static # 文件夹│ ├─css # 文件夹│ │ demo.css│ ││ ├─images # 文件夹│ │ 1.png│ ││ └─js # 文件夹│ demo.js│├─templates # 文件夹 index.html app.py 123456...@app.route(&#x27;/&#x27;)def hello_world(): return render_template(&#x27;index.html&#x27;)... index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;静态文件加载&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(&#x27;static&#x27;,filename=&#x27;css/demo.css&#x27;) &#125;&#125;&quot;&gt; &lt;script src=&quot;&#123;&#123; url_for(&#x27;static&#x27;,filename=&#x27;js/demo.js&#x27;) &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;img src=&quot;&#123;&#123; url_for(&#x27;static&#x27;,filename=&#x27;images/1.png&#x27;) &#125;&#125;&quot;&gt;&lt;/body&gt;&lt;/html&gt; demo.css 123body&#123; background: red;&#125; demo.js 1alert(&#x27;hello world&#x27;) 4.2.1.7 模板的继承 jinja2的模板继承可以把一些公共的代码定义到一个基模板中，比如把导航栏、页脚等通用内容放在基模板中，以后所有的子模板直接继承基模板，在子模板被渲染时会自动包含继承基模板的内容，通过模板的继承可以避免在多个模板中编写重复的代码。 具体实现： 在基模板中定义一些公共的代码，子模板会继承这些公共的代码，但是子模板需要根据自己的需求去实现不同的代码，这个时候就需要在基模板中提供一些接口，以便子模板实现自己的业务需求。 1 基本写法 在基/父模板中定义接口（block） 123&#123;% block main %&#125; &#123;# main是自定义的变量名 #&#125;&#123;% endblock %&#125; 在子模板中继承父模板，并且重写接口（block） 1234&#123;% extends &#39;base.html&#39; %&#125; &#123;# extends 后面跟的参数是导入的基模板相对于templates的路径 #&#125;&#123;% block main %&#125; &#123;% endblock %&#125; 2 子模板中调用父模板代码block中的代码 基模板中 1234&#123;% block main %&#125;&lt;p&gt;父模板中main中原有的内容&lt;&#x2F;p&gt;&#123;% endblock %&#125; 子模板中： 1234&#123;% block main %&#125; &#123;&#123; super() &#125;&#125; &#123;# 保留基模板中本块的代码 #&#125; &lt;p&gt;子模板中重写main的内容 &lt;&#x2F;p&gt;&#123;% endblock %&#125; 3 在子模板中调用其他block中的代码： 子模板中： 1234&#123;% block main %&#125; &#123;&#123; self.demo() &#125;&#125; &#123;# self.其他block名字 #&#125; &lt;p&gt;子模板中重写main的内容 &lt;&#x2F;p&gt;&#123;% endblock %&#125; 4 子模板中的想定义自己的代码只能放到block中，否则无效 示例 注：这里面使用了bootstrap框架。 bootstrap3的中文官网：https://v3.bootcss.com/ 1 首先下载 用于生产环境的 Bootstrap 2 解压出来里面的css文件 项目目录 12345678910111213141516│ app.py│├─static # 文件夹│ └─css│ bootstrap-theme.css│ bootstrap-theme.css.map│ bootstrap-theme.min.css│ bootstrap-theme.min.css.map│ bootstrap.css│ bootstrap.css.map│ bootstrap.min.css│ bootstrap.min.css.map│├─templates # 文件夹 base.html detail.html css文件夹： 是从我们上面下载好的用于生产环境的 Bootstrap中解压出来的 base.html 注意：里面的form标签中的内容和nav标签中的内容均是bootstrap框架的代码截取，div标签是用于清除浮动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;父模板&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(&#x27;static&#x27;,filename=&#x27;css/bootstrap.css&#x27;) &#125;&#125;&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;div style=&quot; visibility:hidden;display:block;font-size:0;clear:both; height:50px&quot;&gt;&lt;/div&gt; &#123;% block main %&#125; &lt;p&gt;父模板中main中原有的内容&lt;/p&gt; &#123;% endblock %&#125; &lt;br&gt; &lt;br&gt; &lt;br&gt; &#123;% block demo %&#125; &lt;p&gt;demo中原有的内容&lt;/p&gt; &#123;% endblock %&#125;&lt;div style=&quot; visibility:hidden;display:block;font-size:0;clear:both; height:0&quot;&gt;&lt;/div&gt;&lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; detail.html 123456789&#123;% extends &#39;base.html&#39; %&#125;&#123;% block demo %&#125; &lt;p&gt;子模板中重写demo的内容&lt;&#x2F;p&gt;&#123;% endblock %&#125;&#123;% block main %&#125; &#123;&#123; super() &#125;&#125; &#123;# 保留基模板中本block的代码 #&#125; &#123;&#123; self.demo() &#125;&#125; &#123;# 调用demo block的代码 #&#125; &lt;p&gt;子模板中重写main的内容 &lt;&#x2F;p&gt;&#123;% endblock %&#125; app.py 注意：app.config.update(TEMPLATES_AUTO_RELOAD=True)语句用于每次都重新加载模板文件 12345678910111213141516from flask import Flask, render_templateapp = Flask(__name__)app.config.update(TEMPLATES_AUTO_RELOAD=True)@app.route(&#x27;/&#x27;)def hello_world(): return render_template(&#x27;base.html&#x27;)@app.route(&#x27;/demo/&#x27;)def demo(): return render_template(&#x27;detail.html&#x27;)if __name__ == &#x27;__main__&#x27;: app.run() 子模板运行效果 4.3 闪现 4.3.1 在模板中获取闪现信息 Flask 提供了一个非常简单的方法来使用闪现系统向用户反馈信息。闪现系统使得在一个请求结束的时候记录一个信息，然后在且仅仅在下一个请求中访问这个数据，强调flask闪现是基于flask内置的session的，利用浏览器的session缓存闪现信息。所以必须设置secret_key。 4.3.1.1 简单的在模板中实现获取闪现信息 示例： server.py 123456789101112131415161718192021222324from flask import Flask, flash, redirect, render_template, \\ request, url_forapp = Flask(__name__)app.secret_key = &#x27;some_secret&#x27;@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login(): error = None if request.method == &#x27;POST&#x27;: if request.form[&#x27;username&#x27;] != &#x27;admin&#x27; or \\ request.form[&#x27;password&#x27;] != &#x27;123&#x27;: error = &#x27;登录失败&#x27; else: flash(&#x27;恭喜您登录成功&#x27;) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;login.html&#x27;, error=error)if __name__ == &quot;__main__&quot;: app.run() 注：这个 flash() 就可以实现在下一次请求时候，将括号内的信息做一个缓存。不要忘记设置secret_key index.html 模板: 123456789101112&#123;% with messages = get_flashed_messages() %&#125; // 获取所有的闪现信息返回一个列表 &#123;% if messages %&#125; &lt;ul class=flashes&gt; &#123;% for message in messages %&#125; &lt;li&gt;&#123;&#123; message &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endif %&#125;&#123;% endwith %&#125;&lt;h1&gt;主页&lt;/h1&gt; &lt;p&gt;跳转到登录页面&lt;a href=&quot;&#123;&#123; url_for(&#x27;login&#x27;) &#125;&#125;&quot;&gt;登录?&lt;/a&gt; 注意：&#123;% with messages = get_flashed_messages() %&#125; 获取所有的闪现信息返回一个列表 login.html 模板 1234567891011&lt;h1&gt;登录页面&lt;/h1&gt;&#123;% if error %&#125;&lt;p class=error&gt;&lt;strong&gt;Error:&lt;/strong&gt; &#123;&#123; error &#125;&#125;&#123;% endif %&#125; &lt;form action=&quot;&quot; method=post&gt; 用户名: &lt;input type=text name=username&gt; 密码: &lt;input type=password name=password&gt; &lt;p&gt;&lt;input type=submit value=Login&gt;&lt;/p&gt;&lt;/form&gt; 简单的在模板中实现获取闪现信息小结： 12设置闪现内容：flash(&#x27;恭喜您登录成功&#x27;)模板取出闪现内容：&#123;% with messages = get_flashed_messages() %&#125; 4.3.1.2 模板中的分类闪现 当闪现一个消息时，是可以提供一个分类的。未指定分类时默认的分类为 'message' 。 可以使用分类来提供给用户更好的反馈，可以给用户更精准的提示信息体验。 要使用一个自定义的分类，只要使用 flash() 函数的第二个参数: 12flash(&#x27;恭喜您登录成功&#x27;,&quot;status&quot;)flash(&#x27;您的账户名为admin&#x27;,&quot;username&quot;) 在使用get_flashed_messages()时候需要传入with_categories=true便可以渲染出来类别 123456789&#123;% with messages &#x3D; get_flashed_messages(with_categories&#x3D;true) %&#125; &#123;% if messages %&#125; &lt;ul class&#x3D;flashes&gt; &#123;% for category, message in messages %&#125; &lt;li class&#x3D;&quot;&#123;&#123; category &#125;&#125;&quot;&gt;&#123;&#123; category &#125;&#125;：&#123;&#123; message &#125;&#125;&lt;&#x2F;li&gt; &#123;% endfor %&#125; &lt;&#x2F;ul&gt; &#123;% endif %&#125;&#123;% endwith %&#125; 模板中的分类闪现小结： 12345678分类设置闪现内容：flash(&#x27;恭喜您登录成功&#x27;,&quot;status&quot;) flash(&#x27;您的账户名为admin&#x27;,&quot;username&quot;)模板取值： &#123;% with messages = get_flashed_messages(with_categories=true) %&#125; &#123;% if messages %&#125; &lt;ul class=flashes&gt; &#123;% for category, message in messages %&#125; ... 4.3.1.3 模板中过滤闪现消息 同样要使用一个自定义的分类，只要使用 flash() 函数的第二个参数: 12flash(&#x27;恭喜您登录成功&#x27;,&quot;status&quot;)flash(&#x27;您的账户名为admin&#x27;,&quot;username&quot;) 在使用get_flashed_messages()时候需要传入category_filter=[&quot;username&quot;]便可根据类别取出闪现信息。中括号内可以传入的值就是类别，可以传入多个。 12345678910&#123;% with messages &#x3D; get_flashed_messages(category_filter&#x3D;[&quot;username&quot;]) %&#125;&#123;% if messages %&#125; &lt;ul&gt; &#123;%- for message in messages %&#125; &lt;li&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;li&gt; &#123;% endfor -%&#125; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&#123;% endif %&#125;&#123;% endwith %&#125; 小结： 123456分类设置闪现内容：flash(&#x27;恭喜您登录成功&#x27;,&quot;status&quot;) flash(&#x27;您的账户名为admin&#x27;,&quot;username&quot;)模板取值： % with messages = get_flashed_messages(category_filter=[&quot;username&quot;]) %&#125; &#123;% if messages %&#125; &lt;ul&gt; &#123;%- for message in messages %&#125; 4.3.2 在视图中获取闪现信息 4.3.2.1 简单的在是视图中获取闪现信息 123-设置: flash(&#x27;xxx&#x27;)-取值：get_flashed_message() # 注意这个不同于模板取值，这个是从flask中导入的-注意：在视图中获取闪现信息不必非得是两次连续的请求，只要保证是第一次取相应的闪现信息，就可以取得到。 示例： 12345678910111213141516171819202122232425from flask import Flask, request, flash, get_flashed_messagesimport osapp = Flask(__name__)app.secret_key = os.urandom(4)app.debug = True@app.route(&#x27;/login/&#x27;)def login(): if request.args.get(&#x27;name&#x27;) == &#x27;rocky&#x27;: return &#x27;ok&#x27; flash(&#x27;第一条闪现信息：用户名不是rocky填写的是&#123;&#125;&#x27;.format(request.args.get(&#x27;name&#x27;))) # flash(&#x27;第二条闪现信息：用户名不是rocky填写的是&#123;&#125;&#x27;.format(request.args.get(&#x27;name&#x27;))) return &#x27;error,设置了闪现&#x27;@app.route(&#x27;/get_flash/&#x27;)def get_flash(): #get_flashed_messages()是一个列表列表可以取出闪现信息，该条闪现信息只要被取出就会删除掉。 return &#x27;闪现的信息是&#123;&#125;&#x27;.format(get_flashed_messages())@app.route(&#x27;/demo/&#x27;)def demo(): return &#x27;demo&#x27;if __name__ == &#x27;__main__&#x27;: app.run() **（1）**会触发设置闪现内容 **（2）**取出闪现内容 **（3）**再次取出闪现内容，发现闪现内容取出一次后就为空了 小结： get_flashed_messages()是一个列表，该列表可以取出闪现信息，该条闪现信息只要被取出就会删除掉。 4.3.2.2 在视图中实现分类获取闪现信息。 12345678910-设置：flash(&#x27;用户名错误&#x27;, &quot;username_error&quot;) flash(&#x27;用户密码错误&#x27;, &quot;password_error&quot;) # 第二个参数为闪现信息的分类。-取所有闪现信息的类别和闪现内容：get_flashed_messages(with_categories=True) -针对分类过滤取值：get_flashed_messages(category_filter=[&#x27;username_error&#x27;]) # 中括号内可以写多个分类。 -注意：如果flash()没有传入第二个参数进行分类，默认分类是 &#x27;message&#x27; 示例1 12345678910@app.route(&#x27;/login/&#x27;)def login(): if request.args.get(&#x27;name&#x27;) == &#x27;rocky&#x27;: return &#x27;ok&#x27; flash(&#x27;用户名错误&#x27;, category=&quot;username_error&quot;) flash(&#x27;用户密码错误&#x27;, &quot;password_error&quot;) return &#x27;error,设置了闪现&#x27;@app.route(&#x27;/get_flash/&#x27;)def get_flash(): return &#x27;闪现的信息是&#123;&#125;&#x27;.format(get_flashed_messages(with_categories=True)) 把所有的闪现类别和闪现信息返回。 示例2 12345678910@app.route(&#x27;/login/&#x27;)def login(): if request.args.get(&#x27;name&#x27;) == &#x27;rocky&#x27;: return &#x27;ok&#x27; flash(&#x27;用户名错误&#x27;, category=&quot;username_error&quot;) flash(&#x27;用户密码错误&#x27;, &quot;password_error&quot;) return &#x27;error,设置了闪现&#x27;@app.route(&#x27;/get_flash/&#x27;)def get_flash(): return &#x27;闪现的信息是&#123;&#125;&#x27;.format(get_flashed_messages(category_filter=[&#x27;username_error&#x27;])) 返回页面只显示了 &quot;username_error&quot;的分类内容。","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]},{"title":"7 flask小点补充","slug":"flask/7 flask小点补充","date":"2021-01-18T09:01:48.487Z","updated":"2021-01-18T14:31:19.976Z","comments":true,"path":"2021/01/18/flask/7 flask小点补充/","link":"","permalink":"http://example.com/2021/01/18/flask/7%20flask%E5%B0%8F%E7%82%B9%E8%A1%A5%E5%85%85/","excerpt":"","text":"1 cookie 1.1 什么是cookie？ cookie技术产生源于HTTP协议在互联网上的急速发展，在浏览器发展初期，为了适应用户的需求，技术上推出了各种保持web浏览状态的手段，为什么要保持web浏览器的状态呢？ 一般web通信是基于HTTP的，HTTP是无状态的协议，也就是说，在一次请求响应结束后，服务器不会留下任何有关于对方状态信息，所以需要保持web浏览器的状态。 比如：对于有些web应用来说，客户端的某些信息必须被记住。比如用户登录过后跳转页面依然要保持登录的状态，进行其他的业务访问，而当这个登录过的用户再次访问web服务器的时候，web服务器并不知道这个用户已经登录过了，所以无法进行其他需要权限的业务访问。所以cookie技术的出现就是为了解决这个问题。 cookie的具体实现过程：当一个用户访问web服务器后，web服务器会获取用户的状态并且返回一些数据（cookie）给浏览器，浏览器会自动储存这些数据（cookie），当用户再次访问web服务器，浏览器会把cookie放到请求报文中发送给web服务器，web服务器就会获取到了用户的状态。基于这次用户的状态方便用户进行其他业务的访问，并且web服务器可以设置浏览器保存cookie的时间，cookie是有域名的概念，只有访问同一个域名的时候才会把之前相同域名返回的cookie携带给该web服务器。 附注：1993年，网景公司雇员Lou Montulli为了提升用户体验，进一步实现了个人化网络。发明了今天广泛使用的Cookie。 关键词： web通讯一般基于HTTP协议，HTTP是无状态协议。 Cookie技术是用来保持web访问状态，Cookie技术通过在请求和响应报文中添加Cookie数据来保存客户端的状态信息 服务器可以设置cookie的有效期，浏览器会自动清除过期的cookie。 cookie有域名的概念，只有访问同一个域名，才会把之前相同域名返回的cookie携带给该服务器。 1.2 如何在flask中使用cookie？ 1.2.1 设置cookie 设置cookie的时候是由我们web服务器设置，也就是在Flask项目中生成cookie，经由响应报文返回给浏览器保存cookie，下次浏览器再访问web服务器的时会在请求报文中把cookie携带过来，所以cookie产生的起点是在web服务器中，也就是我们的Flask项目中。 在Flask中如果想要在响应中添加一个cookie，最方便的做法是使用内置的Response类提供的set_cookie()方法。 表-2.2.1.1 set_cookie()方法的参数 属性 说明 key cookie的键（名称） value cookie的值 max_age cookie被保存的时间数，单位为秒。 expires 具体的过期时间，一个datetime对象或UNIX时间戳 path 限制cookie只在给定的路径可用，默认为整个域名下路径都可用 domain 设置cookie可用的域名，默认是当前域名，子域名需要利用通配符domain=.当前域名 secure 如果设为True，只有通过HTTPS才可以用 httponly 如果设为True，进制客户端JavaScript获取cookie 1.2.1.2 示例：设置cookie 项目目录 1234│ app.py│├─static # 文件夹└─templates # 文件夹 app.py 1234567891011121314from flask import Flask, Responseapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world(): resp = Response(&#x27;设置cookie给浏览器&#x27;) resp.set_cookie(&#x27;user_name&#x27;, &#x27;mark&#x27;) return respif __name__ == &#x27;__main__&#x27;: app.run() 解读 app.py： (1) 首先导入Flask内置的Response类，用于在响应报文中设置cookie 1from flask import Flask,request, Response (2) 在视图函数实例化Response类并传入返回的内容，Response类实例化出的对象调用set_cookie()方 法，set_cookie内的第一个参数是设置cookie的key，第二个参数是用来设置cookie的value，然后返回该对象，就会携带着设置好的cookie返回给浏览器保存。 123456@app.route(&#x27;/&#x27;)def hello_world(): resp = Response(&#x27;设置cookie给浏览器&#x27;) resp.set_cookie(&#x27;user_name&#x27;, &#x27;mark&#x27;) return resp 1.2.1.3 在浏览器中查看cookie的三种方式（以Chrome浏览器为例）** 基于2.2.1.2实例 第一种: 右键检查-----&gt;Network----&gt;找到访问的域名----&gt;找到Response Headers----&gt;Set-Cookie 第二种：点击url输入框左边的信息icon，然后找到响应的域名，展开查看cookie。 第三种：设置----&gt;高级----&gt;内容设置----&gt;Cookie----&gt;查看所有cookie设置-----&gt;根据域名搜索对应的cookie信息 1.2.2 设置cookie的有效期 注意：Flask服务器默认设置cookie有效期为关闭浏览器后cookie失效。 1.2.2.1 基于max_age参数设置cookie有效期 再设置cookie的调用set_cookie()时候传入关键字实参 max_age= 值，这个值代表多少秒后过期。 注意：max_age参数设置过期时间不兼容IE8一下的浏览器 12345678...@app.route(&#x27;/&#x27;)def hello_world(): resp = Response(&#x27;设置cookie给浏览器&#x27;) resp.set_cookie(&#x27;user_name&#x27;, &#x27;mark&#x27;,max_age=60) return resp... 1.2.2.2 基于expires参数设置cookie有效期 再设置cookie的调用set_cookie()时候传入关键字实参 expires= 值，这个值代具体的过期时间，一个datetime对象或UNIX时间戳。 使用expires参数，就必须会用格林尼治时间（也就是相对北京时间少8个小时，因为浏览器会默认把服务器传来的时间值当做标准格林尼治时间，并根据当地的时区做调整 。 123456@app.route(&#x27;/expires_demo/&#x27;)def expires_demo(): resp = Response(&#x27;设置cookie给浏览器, cookie设置过期时间为一个月后&#x27;) expires = datetime.now()+timedelta(days=30, hours=16) resp.set_cookie(&#x27;user_name&#x27;, &#x27;mark&#x27;, expires=expires) return resp 1.2.3 在Flask中查询cookie 基于2.2.1.2 示例 查询cookie 是通过请求对象的cookies属性读取，读取的过程是使用设置cookie时的key来读取到设置cookie的value 123456789...@app.route(&#x27;/get_cookie/&#x27;)def get_cookie(): user_name = request.cookies.get(&#x27;user_name&#x27;) if user_name == &#x27;mark&#x27;: return &#x27;&#123;&#125;的信息&#x27;.format(user_name) return &#x27;cookie验证失败&#x27;... 1.2.4删除cookie 基于2.2.1.2实例 删除cookie是通过Flask内置的Response类实例化出的对象调用delete_cookie('key')，删除的过程是使用设置cookie时的key来删除cookie信息。 12345@app.route(&#x27;/del/&#x27;)def del_cookie(): resp = Response(&#x27;删除cookie&#x27;) resp.delete_cookie(&#x27;user_name&#x27;) return resp 2 session 2.1 什么是session？ session的基本概念：session又称之为安全的cookie，session是一个思路、是一个概念、一个服务器存储授权信息的解决方案，不同的服务器，不同的框架，不同的语言有不同的实现，session的目的和cookie完全一致，cookie在客户端和服务端处理的非常粗糙，cookie在浏览器保存的时候以及传输的过程均使用明文，导致了很多安全隐患问题，session的出现就是为了解决cookie存储数据不安全的问题。 注意：session是一个思路一个概念，session的实现是基于cookie的，session并不像cookie是一项真实存在的技术，可以简单的理解为把粗糙的cookie在服务端通过加密，永久化等方式提高cookie的安全级别。 2.2 实现session的两种思路 第一种 客户端携带用户信息请求服务端验证。 服务端验证成功后生成随机的session_id与用户信息建立映射后存储到数据库中（注意：数据库可以是任意永久化保存数据的机制，如redis、memcached、mysql、甚至是文件等等）。 服务端把刚刚生成的session_id作为cookie信息返回给客户端。 客户端收到以session_id为内容的cookie信息保存到本地。 客户端再次请求的时候会携带以session_id为内容的cookie去访问服务端，服务端取出session_id去数据库校验得到用户信息。 第二种 客户端携带用户信息请求服务端验证。 服务端收到用户信息验证成功后，服务端再把用户信息经过严格的加密加盐生成session信息。并且把刚刚生成的session信息作为cookie的内容返回给客户端。 客户端收到以session信息为内容的cookie保存到本地。 客户端再次请求的时候会携带以session信息为内容的cookie去访问服务端，服务端取出session信息经过解密得到用户的信息。 注意：flask使用的就是第二种思路，利用加密解密的方式实现session，实现安全的cookie，服务端并不会做永久化的储存。 2.3 如何在flask中实现session？ 2.3.1 设置session Flask提供了session对象用来将cookie加密储存，session通过秘钥对数据进行签名以加密数据。 1234567891011from flask import Flask, sessionimport osapp = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(24) # 配置session使用的秘钥@app.route(&#x27;/&#x27;)def set_session_info(): session[&#x27;username&#x27;] = &#x27;mark&#x27; # 使用用户信息配置sesion信息作为cookie，并添加到响应体中 return &#x27;设置session信息&#x27; 解读 通过app对象 通过SECRET_KEY配置session使用的加密秘钥 1app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(24) # 配置session使用的秘钥 session对象像可以字典一样操作，内部是把字典的信息进行加密操作然后添加到相应体中作为cookie，响应的时候会自动返回给浏览器。 12session[&#x27;username&#x27;] = &#x27;mark&#x27;session[&#x27;userphone&#x27;] = &#x27;123456&#x27; # 可以指定多条session信息，统一放到响应的cookie中返回给浏览器 2.3.2 设置session有效期 后端Flask跟浏览器交互默认情况下，session cookie会在用户关闭浏览器时清除。通过将session.permanent属性设为True可以将session的有效期延长为31天，也可以通过操作app的配置PERMANENT_SESSION_LIFETIME来设置session过期时间。 案例 3.3.2.1:开启指定session过期时间模式 1234567891011121314from flask import Flask, sessionimport osapp = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(24)@app.route(&#x27;/&#x27;)def set_session_info(): session[&#x27;username&#x27;] = &#x27;mark&#x27; session[&#x27;userphone&#x27;] = &#x27;123456&#x27; session.permanent = True # 开启设置有效期，默认为31天后过期 return &#x27;Hello World!&#x27;... 案例 3.3.2.1:开启session指定过期时间模式后指定具体的过期时间 基于案例3.3.2.1，通过设置PERMANENT_SESSION_LIFETIME指定具体的过期时间 12from datetime import timedeltaapp.config[&#x27;PERMANENT_SESSION_LIFETIME&#x27;] = timedelta(hours=1) # 设置为1小时候过期 2.3.3 获取session 在Flask中获取设置的session信息通过session对象获取，session对象是继承了字典类，所以获取的时候是字典的取值方式。其内部会把浏览器传过来的session信息解密。 1234567@app.route(&#x27;/get_session/&#x27;)def get_session(): username = session.get(&#x27;username&#x27;) userphone = session.get(&#x27;userphone&#x27;) if username or userphone: return &quot;&#123;&#125;,&#123;&#125;&quot;.format(username, userphone) return &quot;session为空&quot; 2.3.4 删除session session对象调用pop()可以根据具体的session的key清除掉指定的session信息。 session对象调用clear()可以清除此次请求的浏览器关于本域名的所有session信息 12345@app.route(&#x27;/del_session/&#x27;)def del_session(): session.pop(&#x27;username&#x27;) # session.clear() return &#x27;删除成功&#x27; 3 flask模板上下文处理器 app对象调用context_processor作为模板上下文处理器，视图函数在每一次调用render_template(’’)的时候都会为模板传入@app.context_processor装饰器所装饰函数的返回值，该返回值作为模板变量，但是返回值一定要为字典，如果不想返回任何值，可以返回空字典，否则会报错，返回值可以设置为模板经常要使用的变量，减少了代码的冗余，提高了代码的可维护性。 示例 4.1 1234567891011121314151617181920...@app.route(&#x27;/&#x27;)def hello_world(): context_dict = &#123; &quot;username&quot;: &quot;马克&quot; &#125; return render_template(&#x27;index.html&#x27;, **context_dict)@app.route(&#x27;/detail/&#x27;)def detail(): context_dict = &#123; &quot;username&quot;: &quot;马克&quot; &#125; return render_template(&#x27;detail.html&#x27;, **context_dict)... 示例4.2 示例4.2 利用模板上下文处理器避免了一些代码的冗余，利用该处理器，可以为视图函数每一次返回模板的时候传入设置好的变量，示例4.2实现的效果同示例4.1完全一致。 123456789101112131415...@app.route(&#x27;/&#x27;)def hello_world(): return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/detail/&#x27;)def detail(): return render_template(&#x27;detail.html&#x27;)@app.context_processordef context_processor(): return &#123;&quot;username&quot;:&quot;马克&quot;&#125;... 适用场景：比如登录网站后用户信息始终显示在页面的右上角，我们可以利用模板上下文处理器，做到每次返回模板的时候都为其传入用户信息，减少了代码的冗余，提高了代码的可维护性。 4 闪现 4.1 在模板中获取闪现信息 Flask 提供了一个非常简单的方法来使用闪现系统向用户反馈信息。闪现系统使得在一个请求结束的时候记录一个信息，然后在且仅仅在下一个请求中访问这个数据，强调flask闪现是基于flask内置的session的，利用浏览器的session缓存闪现信息。所以必须设置secret_key。 4.1.1 简单的在模板中实现获取闪现信息 示例： server.py 123456789101112131415161718192021222324from flask import Flask, flash, redirect, render_template, \\ request, url_forapp = Flask(__name__)app.secret_key = &#x27;some_secret&#x27;@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login(): error = None if request.method == &#x27;POST&#x27;: if request.form[&#x27;username&#x27;] != &#x27;admin&#x27; or \\ request.form[&#x27;password&#x27;] != &#x27;123&#x27;: error = &#x27;登录失败&#x27; else: flash(&#x27;恭喜您登录成功&#x27;) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;login.html&#x27;, error=error)if __name__ == &quot;__main__&quot;: app.run() 注意：这个 flash() 就可以实现在下一次请求时候，将括号内的信息做一个缓存。不要忘记设置secret_key 这里是 index.html 模板: 123456789101112&#123;% with messages &#x3D; get_flashed_messages() %&#125; # 获取所有的闪现信息返回一个列表 &#123;% if messages %&#125; &lt;ul class&#x3D;flashes&gt; &#123;% for message in messages %&#125; &lt;li&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;li&gt; &#123;% endfor %&#125; &lt;&#x2F;ul&gt; &#123;% endif %&#125;&#123;% endwith %&#125;&lt;h1&gt;主页&lt;&#x2F;h1&gt; &lt;p&gt;跳转到登录页面&lt;a href&#x3D;&quot;&#123;&#123; url_for(&#39;login&#39;) &#125;&#125;&quot;&gt;登录?&lt;&#x2F;a&gt; 注意：&#123;% with messages = get_flashed_messages() %&#125; 获取所有的闪现信息返回一个列表 这里是login.html 模板 1234567891011&lt;h1&gt;登录页面&lt;/h1&gt;&#123;% if error %&#125;&lt;p class=error&gt;&lt;strong&gt;Error:&lt;/strong&gt; &#123;&#123; error &#125;&#125;&#123;% endif %&#125; &lt;form action=&quot;&quot; method=post&gt; 用户名: &lt;input type=text name=username&gt; 密码: &lt;input type=password name=password&gt; &lt;p&gt;&lt;input type=submit value=Login&gt;&lt;/p&gt;&lt;/form&gt; 简单的在模板中实现获取闪现信息小结： 12设置闪现内容：flash(&#x27;恭喜您登录成功&#x27;)模板取出闪现内容：&#123;% with messages = get_flashed_messages() %&#125; 4.1.2 模板中的分类闪现 当闪现一个消息时，是可以提供一个分类的。未指定分类时默认的分类为 'message' 。 可以使用分类来提供给用户更好的反馈，可以给用户更精准的提示信息体验。 要使用一个自定义的分类，只要使用 flash() 函数的第二个参数: 12flash(&#x27;恭喜您登录成功&#x27;,&quot;status&quot;)flash(&#x27;您的账户名为admin&#x27;,&quot;username&quot;) 在使用get_flashed_messages()时候需要传入with_categories=true便可以渲染出来类别 123456789&#123;% with messages &#x3D; get_flashed_messages(with_categories&#x3D;true) %&#125; &#123;% if messages %&#125; &lt;ul class&#x3D;flashes&gt; &#123;% for category, message in messages %&#125; &lt;li class&#x3D;&quot;&#123;&#123; category &#125;&#125;&quot;&gt;&#123;&#123; category &#125;&#125;：&#123;&#123; message &#125;&#125;&lt;&#x2F;li&gt; &#123;% endfor %&#125; &lt;&#x2F;ul&gt; &#123;% endif %&#125;&#123;% endwith %&#125; 模板中的分类闪现小结： 12345678分类设置闪现内容：flash(&#x27;恭喜您登录成功&#x27;,&quot;status&quot;) flash(&#x27;您的账户名为admin&#x27;,&quot;username&quot;)模板取值： &#123;% with messages = get_flashed_messages(with_categories=true) %&#125; &#123;% if messages %&#125; &lt;ul class=flashes&gt; &#123;% for category, message in messages %&#125; ... 4.1.3 模板中过滤闪现消息 同样要使用一个自定义的分类，只要使用 flash() 函数的第二个参数: 12flash(&#x27;恭喜您登录成功&#x27;,&quot;status&quot;)flash(&#x27;您的账户名为admin&#x27;,&quot;username&quot;) 在使用get_flashed_messages()时候需要传入category_filter=[&quot;username&quot;]便可根据类别取出闪现信息。中括号内可以传入的值就是类别，可以传入多个。 12345678910&#123;% with messages &#x3D; get_flashed_messages(category_filter&#x3D;[&quot;username&quot;]) %&#125;&#123;% if messages %&#125; &lt;ul&gt; &#123;%- for message in messages %&#125; &lt;li&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;li&gt; &#123;% endfor -%&#125; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&#123;% endif %&#125;&#123;% endwith %&#125; 小结： 123456分类设置闪现内容：flash(&#x27;恭喜您登录成功&#x27;,&quot;status&quot;) flash(&#x27;您的账户名为admin&#x27;,&quot;username&quot;)模板取值： % with messages = get_flashed_messages(category_filter=[&quot;username&quot;]) %&#125; &#123;% if messages %&#125; &lt;ul&gt; &#123;%- for message in messages %&#125; 4.2 在视图中获取闪现信息 4.2.1 简单的在是视图中获取闪现信息 123-设置: flash(&#x27;xxx&#x27;)-取值：get_flashed_message() # 注意这个不同于模板取值，这个是从flask中导入的-注意：在视图中获取闪现信息不必非得是两次连续的请求，只要保证是第一次取相应的闪现信息，就可以取得到。 示例： 12345678910111213141516171819202122232425from flask import Flask, request, flash, get_flashed_messagesimport osapp = Flask(__name__)app.secret_key = os.urandom(4)app.debug = True@app.route(&#x27;/login/&#x27;)def login(): if request.args.get(&#x27;name&#x27;) == &#x27;rocky&#x27;: return &#x27;ok&#x27; flash(&#x27;第一条闪现信息：用户名不是rocky填写的是&#123;&#125;&#x27;.format(request.args.get(&#x27;name&#x27;))) # flash(&#x27;第二条闪现信息：用户名不是rocky填写的是&#123;&#125;&#x27;.format(request.args.get(&#x27;name&#x27;))) return &#x27;error,设置了闪现&#x27;@app.route(&#x27;/get_flash/&#x27;)def get_flash(): #get_flashed_messages()是一个列表列表可以取出闪现信息，该条闪现信息只要被取出就会删除掉。 return &#x27;闪现的信息是&#123;&#125;&#x27;.format(get_flashed_messages())@app.route(&#x27;/demo/&#x27;)def demo(): return &#x27;demo&#x27;if __name__ == &#x27;__main__&#x27;: app.run() **（1）**会触发设置闪现内容 **（2）**取出闪现内容 **（3）**再次取出闪现内容，发现闪现内容取出一次后就为空了 小结： get_flashed_messages()是一个列表，该列表可以取出闪现信息，该条闪现信息只要被取出就会删除掉。 4.2.2 在视图中实现分类获取闪现信息。 12345678910-设置：flash(&#x27;用户名错误&#x27;, &quot;username_error&quot;) flash(&#x27;用户密码错误&#x27;, &quot;password_error&quot;) # 第二个参数为闪现信息的分类。-取所有闪现信息的类别和闪现内容：get_flashed_messages(with_categories=True) -针对分类过滤取值：get_flashed_messages(category_filter=[&#x27;username_error&#x27;]) # 中括号内可以写多个分类。 -注意：如果flash()没有传入第二个参数进行分类，默认分类是 &#x27;message&#x27; 示例1 12345678910@app.route(&#x27;/login/&#x27;)def login(): if request.args.get(&#x27;name&#x27;) == &#x27;rocky&#x27;: return &#x27;ok&#x27; flash(&#x27;用户名错误&#x27;, category=&quot;username_error&quot;) flash(&#x27;用户密码错误&#x27;, &quot;password_error&quot;) return &#x27;error,设置了闪现&#x27;@app.route(&#x27;/get_flash/&#x27;)def get_flash(): return &#x27;闪现的信息是&#123;&#125;&#x27;.format(get_flashed_messages(with_categories=True)) 把所有的闪现类别和闪现信息返回。 示例2 12345678910@app.route(&#x27;/login/&#x27;)def login(): if request.args.get(&#x27;name&#x27;) == &#x27;rocky&#x27;: return &#x27;ok&#x27; flash(&#x27;用户名错误&#x27;, category=&quot;username_error&quot;) flash(&#x27;用户密码错误&#x27;, &quot;password_error&quot;) return &#x27;error,设置了闪现&#x27;@app.route(&#x27;/get_flash/&#x27;)def get_flash(): return &#x27;闪现的信息是&#123;&#125;&#x27;.format(get_flashed_messages(category_filter=[&#x27;username_error&#x27;])) 返回页面只显示了 &quot;username_error&quot;的分类内容。 [","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]}],"categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"python框架","slug":"python框架","permalink":"http://example.com/categories/python%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"}]}