{"title":"8-4 flask请求上下文","slug":"flask/8-4 flask请求上下文","date":"2021-01-18T11:39:27.112Z","updated":"2021-01-19T08:30:33.579Z","comments":true,"path":"api/articles/flask/8-4 flask请求上下文.json","excerpt":null,"covers":["https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155553388-420550334..png","https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155554088-541734375..png"],"content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n<p>在分析上下问之前，要做好一个心理准备，因为设计到的代码会很多，需要不懂的要跟着文档自己去翻阅源码。</p>\n<p>首先把涉及到的主要的类或者设计到的 py 页面展示如下图。下面我会以对应类或者页面去讲解flask源码</p>\n<p><a href=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155553388-420550334..png\"><img src=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155553388-420550334..png\" alt=\"1553480943160\" /></a></p>\n<p>之前我们已经论述过了，每次请求过来都会触发<code>app()</code>，所以会触发<code>FLask</code>类的<code>__call__</code>方法，<code>__call__</code>方法会触发<code>Flask</code>类的<code>wsgi_app()</code>方法。然后所有的请求的整个生命周期都在整个<code>wsgi_app()</code>里面了。</p>\n<p>根据上图类和序号来完成我们的分析流程。</p>\n<h2 id=\"1-首先分析请求上下文对象ctx创立\"><a class=\"markdownIt-Anchor\" href=\"#1-首先分析请求上下文对象ctx创立\"></a> 1 首先分析请求上下文对象(ctx)创立</h2>\n<ul>\n<li>\n<p>1.0 FLask 类中的<code>wsgi_app()</code>中的 <code>ctx = self.request_context(environ）</code></p>\n</li>\n<li>\n<p>1.1 <code>RequestContext</code>类中的 <code>__init__</code></p>\n<ul>\n<li>\n<p>实例化出请求上下文对象ctx</p>\n</li>\n<li>\n<p>并且关注：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> request <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">    request = app.request_class(environ)</span><br><span class=\"line\">self.request = request</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>1.2 Request类中的 <code>__init__</code></p>\n<ul>\n<li>该类的 <code>__init__</code>方法实例化出<code>reqeust</code>对象</li>\n</ul>\n<p>这三部完成了初始化一个用户请求相关的数据，也就是请求上下文对象。</p>\n</li>\n</ul>\n<p>1.0中的<code>ctx</code>就是<code>RequestContext</code>对象，请求上下文对象<code>ctx</code>中初始化所有请求所有内容，并且其内部封装着Request对象，Request对象把请求过来的信息格式化并且储存起来。</p>\n<h2 id=\"2-把请求对象ctx添加到local中入栈\"><a class=\"markdownIt-Anchor\" href=\"#2-把请求对象ctx添加到local中入栈\"></a> 2 把请求对象(ctx)添加到local中（入栈）</h2>\n<ul>\n<li>\n<p>2.0 FLask 类中的<code>wsgi_app()</code>中的 <code>ctx.push()</code></p>\n</li>\n<li>\n<p>2.1 <code>RequestContext</code> 类中的 push() 下</p>\n<ul>\n<li>只关注<code>_request_ctx_stack.push(self)</code></li>\n</ul>\n</li>\n<li>\n<p>2.2 <code>LocalStack</code>类中的 push()方法</p>\n<ul>\n<li>只关注 <code>self._local.stack = rv = []</code>，触发2.3执行。</li>\n<li>在实现了2.3的基础上，关注本方法中的<code>rv.append(obj)</code> , rv就是2.3中stack的value值，此obj就是ctx对象 ，相当于为Local类中的storage里面的<code>当前线程或携程唯一标识</code>里的<code>stack</code>对应的<code>value</code>值，添加了球队上下文对象ctx，这个对象里面包含了所有请求过来的信息。</li>\n</ul>\n<p>{</p>\n<p>线程或携程唯一标识:{</p>\n<p>stack:[请求上下文对象ctx]。</p>\n<p>}，</p>\n<p>}</p>\n</li>\n<li>\n<p>2.3 Local类中的 <code>__setattr__</code>方法实现了创建了</p>\n<ul>\n<li>\n<p>storage = {</p>\n<p>线程或携程唯一标识:{</p>\n<p>stack: [ ]</p>\n<p>}，</p>\n<p>}</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-找到视图函数并且使用导入request对象\"><a class=\"markdownIt-Anchor\" href=\"#3-找到视图函数并且使用导入request对象\"></a> 3 找到视图函数并且使用导入request对象**</h2>\n<ul>\n<li>\n<p>3.0 FLask 类中的<code>wsgi_app()</code>中 <code>response = self.full_dispatch_request()</code>的找到视图函数并执行</p>\n</li>\n<li>\n<p>3.1 找到了视图函数并且执行<code>request.method</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@app.route(&#39;&#x2F;&#39;)</span><br><span class=\"line\">def index():</span><br><span class=\"line\">    v &#x3D; request.method</span><br><span class=\"line\">    return  v</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>3.2 须知：<code>request = LocalProxy(partial(_lookup_req_object, 'request'))</code> 用于在视图函数里导入的request对象</p>\n<ul>\n<li>偏函数：<code>partial(_lookup_req_object, 'request')</code><em>不懂可以翻阅之前的文章</em></li>\n</ul>\n</li>\n<li>\n<p>3.3 触发了<code>LocalProxy</code>类 中的 <code>__getattr__</code></p>\n<ul>\n<li>关注：<code>return getattr(self._get_current_object(), name)</code>  # name是‘method’，去Request类中查询‘method’属性，</li>\n</ul>\n</li>\n<li>\n<p>3.4 触发了<code>LocalProxy</code>类 中的 <code>_get_current_object()</code></p>\n<ul>\n<li>\n<p>关注 <code>return self.__local()</code> #返回了Request对象</p>\n<p>在<code>LocalProxy</code>类实例化的时候使得<code>self.__local</code>的值就是实例化时传入偏函数。所以会返回偏函数运行结果。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>3.5 触发了<code>globals.py</code> 里的 <code>_lookup_req_object()</code>运行。</p>\n<ul>\n<li>关注 <code>top = _request_ctx_stack.top</code> # 触发3.6执行</li>\n<li><code>return getattr(top, name) # name = ‘request’</code>，所以返回了Request对象</li>\n</ul>\n</li>\n<li>\n<p>3.6 触发了<code>LocalStack</code>类中的<code>top()</code>方法：</p>\n<ul>\n<li>关注 <code>return self._local.stack[-1]</code> # 返回了请求上下文<code>ctx</code>对象。</li>\n</ul>\n</li>\n<li>\n<p>3.7 触发了Local类中的<code>__getattr__（）</code>方法</p>\n<ul>\n<li>关注<code>return self.__storage__[self.__ident_func__()][name]</code> #返回了当前线程或携程的stack对应的value值，可以理解为返回了 <code>[ctx对象]</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-请求结束时从local中移除上下文对象出栈\"><a class=\"markdownIt-Anchor\" href=\"#4-请求结束时从local中移除上下文对象出栈\"></a> 4 请求结束时从Local中移除上下文对象（出栈）</h2>\n<p>经过了添加请求上下文到<code>Local</code>的<code>storage</code>中，以及视图函数的运行返回相应对象，我们现在进行把请求上下文对象从storage中移除。</p>\n<ul>\n<li>\n<p>4.0 FLask 类中的<code>wsgi_app()</code>中 <code>ctx.auto_pop()</code></p>\n</li>\n<li>\n<p>4.1 触发了 <code>RequestContext</code>类中的 auto_pop()</p>\n<ul>\n<li>关注 <code>self.pop()</code></li>\n</ul>\n</li>\n<li>\n<p>4.2 触发了 <code>RequestContext</code>类中的 pop() 方法</p>\n<ul>\n<li><code>rv = _request_ctx_stack.pop()</code></li>\n</ul>\n</li>\n<li>\n<p>4.3 触发了 <code>LocalStack</code>类中的pop()的pop方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">elif</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">1</span>: <span class=\"comment\"># 证明push过一次 添加过了一次对象</span></span><br><span class=\"line\">    release_local(self._local) <span class=\"comment\"># 在这里pop掉该线程。release_local pop掉的是一个字典</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack[-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>4.4 触发了 Local类中的<code>__release_local__()</code> 方法</p>\n<ul>\n<li>\n<pre class=\"highlight\"><code class=\"python\">self.__storage__.pop(self.__ident_func__(), <span class=\"hljs-literal\">None</span>) <span class=\"hljs-comment\">#在Local对象中删除掉了当前线程或者携程的请求上下文对象，</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h3>\n<ul>\n<li>\n<p>其实操作flask的请求上下文就是操作Local中的字典<code>__storage__</code></p>\n<ol>\n<li>\n<p>通过<code>REquestContext</code>类首先实例化<code>ctx</code>请求上下文对象，其内部包含请求对象</p>\n</li>\n<li>\n<p>入栈，通过请求上下文对象的类的push()方法触发了<code>LocalStack</code>类的push() 方法，从而添加到Local类中的字典里。</p>\n</li>\n<li>\n<p>观察导入的request源码 ，通过观察<code>LocalProxy</code>的源码，最后触发了<code>LocalStack</code>的<code>top()</code>方法得到上下文对象，再的到请求对象，从而实现<code>reuqest</code>的功能。</p>\n</li>\n<li>\n<p>出站，和入栈原理相同通过请求上下文对象的类的方法，触发了<code>LocalStack</code>的<code>pop()</code>方法从而从字典中删除掉当前线程或当前携程的请求信息。</p>\n<p><a href=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155554088-541734375..png\"><img src=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155554088-541734375..png\" alt=\"1553484834232\" /></a></p>\n</li>\n</ol>\n</li>\n</ul>\n","more":"<meta name=\"referrer\" content=\"no-referrer\"/>\n<p>在分析上下问之前，要做好一个心理准备，因为设计到的代码会很多，需要不懂的要跟着文档自己去翻阅源码。</p>\n<p>首先把涉及到的主要的类或者设计到的 py 页面展示如下图。下面我会以对应类或者页面去讲解flask源码</p>\n<p><a href=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155553388-420550334..png\"><img src=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155553388-420550334..png\" alt=\"1553480943160\" /></a></p>\n<p>之前我们已经论述过了，每次请求过来都会触发<code>app()</code>，所以会触发<code>FLask</code>类的<code>__call__</code>方法，<code>__call__</code>方法会触发<code>Flask</code>类的<code>wsgi_app()</code>方法。然后所有的请求的整个生命周期都在整个<code>wsgi_app()</code>里面了。</p>\n<p>根据上图类和序号来完成我们的分析流程。</p>\n<h2 id=\"1-首先分析请求上下文对象ctx创立\"><a class=\"markdownIt-Anchor\" href=\"#1-首先分析请求上下文对象ctx创立\"></a> 1 首先分析请求上下文对象(ctx)创立</h2>\n<ul>\n<li>\n<p>1.0 FLask 类中的<code>wsgi_app()</code>中的 <code>ctx = self.request_context(environ）</code></p>\n</li>\n<li>\n<p>1.1 <code>RequestContext</code>类中的 <code>__init__</code></p>\n<ul>\n<li>\n<p>实例化出请求上下文对象ctx</p>\n</li>\n<li>\n<p>并且关注：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> request <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">    request = app.request_class(environ)</span><br><span class=\"line\">self.request = request</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>1.2 Request类中的 <code>__init__</code></p>\n<ul>\n<li>该类的 <code>__init__</code>方法实例化出<code>reqeust</code>对象</li>\n</ul>\n<p>这三部完成了初始化一个用户请求相关的数据，也就是请求上下文对象。</p>\n</li>\n</ul>\n<p>1.0中的<code>ctx</code>就是<code>RequestContext</code>对象，请求上下文对象<code>ctx</code>中初始化所有请求所有内容，并且其内部封装着Request对象，Request对象把请求过来的信息格式化并且储存起来。</p>\n<h2 id=\"2-把请求对象ctx添加到local中入栈\"><a class=\"markdownIt-Anchor\" href=\"#2-把请求对象ctx添加到local中入栈\"></a> 2 把请求对象(ctx)添加到local中（入栈）</h2>\n<ul>\n<li>\n<p>2.0 FLask 类中的<code>wsgi_app()</code>中的 <code>ctx.push()</code></p>\n</li>\n<li>\n<p>2.1 <code>RequestContext</code> 类中的 push() 下</p>\n<ul>\n<li>只关注<code>_request_ctx_stack.push(self)</code></li>\n</ul>\n</li>\n<li>\n<p>2.2 <code>LocalStack</code>类中的 push()方法</p>\n<ul>\n<li>只关注 <code>self._local.stack = rv = []</code>，触发2.3执行。</li>\n<li>在实现了2.3的基础上，关注本方法中的<code>rv.append(obj)</code> , rv就是2.3中stack的value值，此obj就是ctx对象 ，相当于为Local类中的storage里面的<code>当前线程或携程唯一标识</code>里的<code>stack</code>对应的<code>value</code>值，添加了球队上下文对象ctx，这个对象里面包含了所有请求过来的信息。</li>\n</ul>\n<p>{</p>\n<p>线程或携程唯一标识:{</p>\n<p>stack:[请求上下文对象ctx]。</p>\n<p>}，</p>\n<p>}</p>\n</li>\n<li>\n<p>2.3 Local类中的 <code>__setattr__</code>方法实现了创建了</p>\n<ul>\n<li>\n<p>storage = {</p>\n<p>线程或携程唯一标识:{</p>\n<p>stack: [ ]</p>\n<p>}，</p>\n<p>}</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-找到视图函数并且使用导入request对象\"><a class=\"markdownIt-Anchor\" href=\"#3-找到视图函数并且使用导入request对象\"></a> 3 找到视图函数并且使用导入request对象**</h2>\n<ul>\n<li>\n<p>3.0 FLask 类中的<code>wsgi_app()</code>中 <code>response = self.full_dispatch_request()</code>的找到视图函数并执行</p>\n</li>\n<li>\n<p>3.1 找到了视图函数并且执行<code>request.method</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@app.route(&#39;&#x2F;&#39;)</span><br><span class=\"line\">def index():</span><br><span class=\"line\">    v &#x3D; request.method</span><br><span class=\"line\">    return  v</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>3.2 须知：<code>request = LocalProxy(partial(_lookup_req_object, 'request'))</code> 用于在视图函数里导入的request对象</p>\n<ul>\n<li>偏函数：<code>partial(_lookup_req_object, 'request')</code><em>不懂可以翻阅之前的文章</em></li>\n</ul>\n</li>\n<li>\n<p>3.3 触发了<code>LocalProxy</code>类 中的 <code>__getattr__</code></p>\n<ul>\n<li>关注：<code>return getattr(self._get_current_object(), name)</code>  # name是‘method’，去Request类中查询‘method’属性，</li>\n</ul>\n</li>\n<li>\n<p>3.4 触发了<code>LocalProxy</code>类 中的 <code>_get_current_object()</code></p>\n<ul>\n<li>\n<p>关注 <code>return self.__local()</code> #返回了Request对象</p>\n<p>在<code>LocalProxy</code>类实例化的时候使得<code>self.__local</code>的值就是实例化时传入偏函数。所以会返回偏函数运行结果。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>3.5 触发了<code>globals.py</code> 里的 <code>_lookup_req_object()</code>运行。</p>\n<ul>\n<li>关注 <code>top = _request_ctx_stack.top</code> # 触发3.6执行</li>\n<li><code>return getattr(top, name) # name = ‘request’</code>，所以返回了Request对象</li>\n</ul>\n</li>\n<li>\n<p>3.6 触发了<code>LocalStack</code>类中的<code>top()</code>方法：</p>\n<ul>\n<li>关注 <code>return self._local.stack[-1]</code> # 返回了请求上下文<code>ctx</code>对象。</li>\n</ul>\n</li>\n<li>\n<p>3.7 触发了Local类中的<code>__getattr__（）</code>方法</p>\n<ul>\n<li>关注<code>return self.__storage__[self.__ident_func__()][name]</code> #返回了当前线程或携程的stack对应的value值，可以理解为返回了 <code>[ctx对象]</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-请求结束时从local中移除上下文对象出栈\"><a class=\"markdownIt-Anchor\" href=\"#4-请求结束时从local中移除上下文对象出栈\"></a> 4 请求结束时从Local中移除上下文对象（出栈）</h2>\n<p>经过了添加请求上下文到<code>Local</code>的<code>storage</code>中，以及视图函数的运行返回相应对象，我们现在进行把请求上下文对象从storage中移除。</p>\n<ul>\n<li>\n<p>4.0 FLask 类中的<code>wsgi_app()</code>中 <code>ctx.auto_pop()</code></p>\n</li>\n<li>\n<p>4.1 触发了 <code>RequestContext</code>类中的 auto_pop()</p>\n<ul>\n<li>关注 <code>self.pop()</code></li>\n</ul>\n</li>\n<li>\n<p>4.2 触发了 <code>RequestContext</code>类中的 pop() 方法</p>\n<ul>\n<li><code>rv = _request_ctx_stack.pop()</code></li>\n</ul>\n</li>\n<li>\n<p>4.3 触发了 <code>LocalStack</code>类中的pop()的pop方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">elif</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">1</span>: <span class=\"comment\"># 证明push过一次 添加过了一次对象</span></span><br><span class=\"line\">    release_local(self._local) <span class=\"comment\"># 在这里pop掉该线程。release_local pop掉的是一个字典</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack[-<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>4.4 触发了 Local类中的<code>__release_local__()</code> 方法</p>\n<ul>\n<li>\n<pre class=\"highlight\"><code class=\"python\">self.__storage__.pop(self.__ident_func__(), <span class=\"hljs-literal\">None</span>) <span class=\"hljs-comment\">#在Local对象中删除掉了当前线程或者携程的请求上下文对象，</span>\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h3>\n<ul>\n<li>\n<p>其实操作flask的请求上下文就是操作Local中的字典<code>__storage__</code></p>\n<ol>\n<li>\n<p>通过<code>REquestContext</code>类首先实例化<code>ctx</code>请求上下文对象，其内部包含请求对象</p>\n</li>\n<li>\n<p>入栈，通过请求上下文对象的类的push()方法触发了<code>LocalStack</code>类的push() 方法，从而添加到Local类中的字典里。</p>\n</li>\n<li>\n<p>观察导入的request源码 ，通过观察<code>LocalProxy</code>的源码，最后触发了<code>LocalStack</code>的<code>top()</code>方法得到上下文对象，再的到请求对象，从而实现<code>reuqest</code>的功能。</p>\n</li>\n<li>\n<p>出站，和入栈原理相同通过请求上下文对象的类的方法，触发了<code>LocalStack</code>的<code>pop()</code>方法从而从字典中删除掉当前线程或当前携程的请求信息。</p>\n<p><a href=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155554088-541734375..png\"><img src=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155554088-541734375..png\" alt=\"1553484834232\" /></a></p>\n</li>\n</ol>\n</li>\n</ul>\n","categories":[{"name":"flask","path":"api/categories/flask.json"}],"tags":[{"name":"flask","path":"api/tags/flask.json"},{"name":"python","path":"api/tags/python.json"}]}