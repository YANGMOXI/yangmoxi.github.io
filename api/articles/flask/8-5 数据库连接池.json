{"title":"8-5 数据库连接池","slug":"flask/8-5 数据库连接池","date":"2021-01-18T11:39:27.117Z","updated":"2021-01-18T15:02:54.366Z","comments":true,"path":"api/articles/flask/8-5 数据库连接池.json","excerpt":null,"covers":["https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155710792-29404033..png","https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155711355-1754252191..png"],"content":"<h2 id=\"01-如何在python中操作数据库\"><a class=\"markdownIt-Anchor\" href=\"#01-如何在python中操作数据库\"></a> 01 如何在python中操作数据库</h2>\n<p>在后端开发中免不掉与数据库打交道，无非是使用<code>orm</code>或者原生<code>sql</code>来操作数据库。</p>\n<p>在python中通过原生sql操作数据库，主流就两种。</p>\n<ul>\n<li>使用pymysql模块：<code>pymysql</code>支持<code>python2.x</code>和<code>python3.x</code>的版本</li>\n<li>使用mysqldb模块：<code>mysqldb</code>仅支持<code>python2.x</code>的版本</li>\n</ul>\n<p>orm的使用以flask和django为例。</p>\n<ul>\n<li>flask使用的orm是基于<code>SQLAlchemy</code>（SQLAlchemy本就是orm），flask团队并在<code>SQLAlchemy</code>基础之上又封装了一个<code>Flask-SQLchemy</code>并予以应用 。</li>\n<li>django使用的orm是django自带的orm。</li>\n</ul>\n<p>orm的操作数据库的方式我们已经熟知了，这里我们聊一聊如何在web中使用原生sql操作数据库，以及会出现的问题。</p>\n<h2 id=\"02-在web中使用原生sqlpymysql操作数据库\"><a class=\"markdownIt-Anchor\" href=\"#02-在web中使用原生sqlpymysql操作数据库\"></a> 02 在web中使用原生sql(pymysql)操作数据库？</h2>\n<h3 id=\"21-在web中通过原生sql操作数据库会出现的问题\"><a class=\"markdownIt-Anchor\" href=\"#21-在web中通过原生sql操作数据库会出现的问题\"></a> 2.1 在web中通过原生sql操作数据库会出现的问题。</h3>\n<p><a href=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155710792-29404033..png\"><img src=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155710792-29404033..png\" alt=\"1554343834169\" /></a></p>\n<h4 id=\"示例1\"><a class=\"markdownIt-Anchor\" href=\"#示例1\"></a> 示例1：</h4>\n<p>把所有的数据库操作全部都放在了视图函数里面。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\">    CONN = pymysql.connect(host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">                           port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">                           user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">                           password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">                           database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">                           charset=<span class=\"string\">&#x27;utf8&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    cursor = CONN.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">    result = cursor.fetchall()</span><br><span class=\"line\">    cursor.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题</strong></p>\n<ul>\n<li>很多个用户并发的来请求，一个用户可以理解为一个线程，每个线程都会跟数据库建立连接，数据库承受不了这种量级的连接数。</li>\n</ul>\n<h4 id=\"示例2\"><a class=\"markdownIt-Anchor\" href=\"#示例2\"></a> 示例2</h4>\n<p>为了避免之前每个用户都建立连接，我们把数据库连接放到了全局变量里面，只会建立一次连接，但是依然会出现问题。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\">CONN = pymysql.connect(host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">                           port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">                           user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">                           password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">                           database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">                           charset=<span class=\"string\">&#x27;utf8&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span>():</span></span><br><span class=\"line\">    cursor = CONN.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">    result = cursor.fetchall()</span><br><span class=\"line\">    cursor.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题：</strong></p>\n<ul>\n<li>会出现线程安全问题，比如如果第一个用户拿到了连接给关闭了，而第二个用户正在进行查询，第二个用户查询的时候第一个用户把连接断了，会导致第二个用户出现问题。</li>\n<li>假设第一用户查询了一下表1，正准备获取查询的内容，这时第二个人查询了一下表2，由于cursor对象都是同一个，第一个人获取到的查询内容就是表2的内容了，所以也会出现线程安全问题</li>\n</ul>\n<h4 id=\"示例3\"><a class=\"markdownIt-Anchor\" href=\"#示例3\"></a> 示例3</h4>\n<p>为了避免之前的线程不安全，在示例2的基础上加上一把线程锁</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\">CONN = pymysql.connect(host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">                           port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">                           user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">                           password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">                           database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">                           charset=<span class=\"string\">&#x27;utf8&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> threading.Lock():</span><br><span class=\"line\">        cursor = CONN.cursor()</span><br><span class=\"line\">        cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">        result = cursor.fetchall()</span><br><span class=\"line\">        cursor.close()</span><br><span class=\"line\"></span><br><span class=\"line\">        print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题</strong>：</p>\n<ul>\n<li>根据代码可以发现，只是在示例2的基础上加了一把线程锁，确实是保证了线程安全，但是所有关于数据库操作的请求变成了串行，无法实现并发了。</li>\n</ul>\n<h4 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结：</h4>\n<ul>\n<li>如果直接连接坐在视图函数中，会导致每个用户都要创建连接，数据库承受不了这种量级的连接数。</li>\n<li>如果连接数据库的内容做成全局变量的话，无法保证线程安全。</li>\n<li>如果定义全局变量用于连接数据库，并且在线程中操作数据库内容加线程锁头，就会变成串行，无法保证并发</li>\n</ul>\n<p>所以我们既要控制数据库的连接数，又要保证线程安全，又要保证web的并发，这个时候最终的解决方案是数据库连接池。</p>\n<h3 id=\"21-什么是数据库连接池呢\"><a class=\"markdownIt-Anchor\" href=\"#21-什么是数据库连接池呢\"></a> 2.1 什么是数据库连接池呢？</h3>\n<p>数据库连接池概念：数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个，这项技术能明显提高对数据库操作的性能。</p>\n<p><strong>图解</strong>：</p>\n<p><a href=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155711355-1754252191..png\"><img src=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155711355-1754252191..png\" alt=\"1553241307822\" /></a></p>\n<p>通俗的讲就是，假设数据库连接池中有5个连接对象，每个用户简单理解为一个线程，比如现在有6个用户同时来访问，6个线程去数据库连接池里面申请数据库的连接对象。前5个线程每个都申请到了连接对象去操作数据库，每个线程使用完了数据库连接对象会归还给数据库连接池，那么第6个线程会等待前5个线程归还连接对象给连接池，再具体一点是：假设第一个线程使用完了连接对象，那么此时6个线程才会结束等待，从而申请到连接对象，以此类推。</p>\n<h3 id=\"22-python数据库连接池dbutiles\"><a class=\"markdownIt-Anchor\" href=\"#22-python数据库连接池dbutiles\"></a> 2.2 Python数据库连接池DBUtiles</h3>\n<p>DBUtils 是Python的一个用于实现数据库连接池的模块。</p>\n<p>首先安装一下DBUtils模块。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install DBUtils</span><br></pre></td></tr></table></figure>\n<p>DBUtils连接池的两种连接模式：</p>\n<p>**模式一：**为每个线程创建一个连接，线程即使调用了close方法，也不会关闭，只是把连接重新放到连接池，仅供自己的线程再次使用，当线程终止时，连接会自动关闭。（不推荐使用，因为这样需要自己控制线程数量）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"><span class=\"keyword\">from</span> DBUtils.PersistentDB <span class=\"keyword\">import</span> PersistentDB</span><br><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> local</span><br><span class=\"line\"></span><br><span class=\"line\">POOL = PersistentDB(</span><br><span class=\"line\">    creator=pymysql,  <span class=\"comment\"># 使用链接数据库的模块</span></span><br><span class=\"line\">    maxusage=<span class=\"literal\">None</span>,  <span class=\"comment\"># 一个链接最多被重复使用的次数，None表示无限制</span></span><br><span class=\"line\">    setsession=[],  <span class=\"comment\"># 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]</span></span><br><span class=\"line\">    ping=<span class=\"number\">0</span>, <span class=\"comment\"># ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always</span></span><br><span class=\"line\">    closeable=<span class=\"literal\">False</span>,</span><br><span class=\"line\">    <span class=\"comment\"># 如果为False时， conn.close() 实际上被忽略，供下次使用，再线程关闭时，才会自动关闭链接。如果为True时， conn.close()则关闭链接，那么再次调用pool.connection时就会报错，因为已经真的关闭了连接（pool.steady_connection()可以获取一个新的链接）</span></span><br><span class=\"line\">    threadlocal=<span class=\"literal\">None</span>,  <span class=\"comment\"># 如果为none，用默认的threading.Loacl对象，否则可以自己封装一个local对象进行替换</span></span><br><span class=\"line\">    host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">    port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">    user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">    password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">    database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">    charset=<span class=\"string\">&#x27;utf8&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span>():</span></span><br><span class=\"line\">    conn = POOL.connection(shareable=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    cursor = conn.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">    result = cursor.fetchall()</span><br><span class=\"line\">    cursor.close()</span><br><span class=\"line\">    conn.close()</span><br><span class=\"line\"></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n<p>**模式二：**创建一批连接到连接池，供所有线程共享使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">from</span> DBUtils.PooledDB <span class=\"keyword\">import</span> PooledDB, SharedDBConnection</span><br><span class=\"line\">POOL = PooledDB(</span><br><span class=\"line\">    creator=pymysql,  <span class=\"comment\"># 使用链接数据库的模块</span></span><br><span class=\"line\">    maxconnections=<span class=\"number\">6</span>,  <span class=\"comment\"># 连接池允许的最大连接数，0和None表示不限制连接数</span></span><br><span class=\"line\">    mincached=<span class=\"number\">2</span>,  <span class=\"comment\"># 初始化时，链接池中至少创建的空闲的链接，0表示不创建</span></span><br><span class=\"line\">    maxcached=<span class=\"number\">5</span>,  <span class=\"comment\"># 链接池中最多闲置的链接，0和None不限制</span></span><br><span class=\"line\">    maxshared=<span class=\"number\">3</span>,  <span class=\"comment\"># 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。</span></span><br><span class=\"line\">    blocking=<span class=\"literal\">True</span>,  <span class=\"comment\"># 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</span></span><br><span class=\"line\">    maxusage=<span class=\"literal\">None</span>,  <span class=\"comment\"># 一个链接最多被重复使用的次数，None表示无限制</span></span><br><span class=\"line\">    setsession=[],  <span class=\"comment\"># 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]</span></span><br><span class=\"line\">    ping=<span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\"># ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always</span></span><br><span class=\"line\">    host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">    port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">    user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">    password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">    database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">    charset=<span class=\"string\">&#x27;utf8&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span>():</span></span><br><span class=\"line\">    conn = POOL.connection()</span><br><span class=\"line\">    cursor = conn.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">    result = cursor.fetchall()</span><br><span class=\"line\">    conn.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n<h3 id=\"23-实际开发小应用案例\"><a class=\"markdownIt-Anchor\" href=\"#23-实际开发小应用案例\"></a> 2.3 实际开发小应用案例：</h3>\n<p><strong>案例目录：</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- app.py</span><br><span class=\"line\">- db_helper.py</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://app.py\">app.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> db_helper <span class=\"keyword\">import</span> SQLHelper</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span>():</span></span><br><span class=\"line\">    result = SQLHelper.fetch_one(<span class=\"string\">&#x27;select * from t1&#x27;</span>,[])</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>db_helper.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"><span class=\"keyword\">from</span> DBUtils.PooledDB <span class=\"keyword\">import</span> PooledDB</span><br><span class=\"line\">POOL = PooledDB(</span><br><span class=\"line\">    creator=pymysql,  <span class=\"comment\"># 使用链接数据库的模块</span></span><br><span class=\"line\">    maxconnections=<span class=\"number\">6</span>,  <span class=\"comment\"># 连接池允许的最大连接数，0和None表示不限制连接数</span></span><br><span class=\"line\">    mincached=<span class=\"number\">2</span>,  <span class=\"comment\"># 初始化时，链接池中至少创建的空闲的链接，0表示不创建</span></span><br><span class=\"line\">    maxcached=<span class=\"number\">5</span>,  <span class=\"comment\"># 链接池中最多闲置的链接，0和None不限制</span></span><br><span class=\"line\">    maxshared=<span class=\"number\">3</span>,  <span class=\"comment\"># 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。</span></span><br><span class=\"line\">    blocking=<span class=\"literal\">True</span>,  <span class=\"comment\"># 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</span></span><br><span class=\"line\">    maxusage=<span class=\"literal\">None</span>,  <span class=\"comment\"># 一个链接最多被重复使用的次数，None表示无限制</span></span><br><span class=\"line\">    setsession=[],  <span class=\"comment\"># 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]</span></span><br><span class=\"line\">    ping=<span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\"># ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always</span></span><br><span class=\"line\">    host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">    port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">    user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">    password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">    database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">    charset=<span class=\"string\">&#x27;utf8&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SQLHelper</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fetch_one</span>(<span class=\"params\">sql,args</span>):</span></span><br><span class=\"line\">        conn = POOL.connection()</span><br><span class=\"line\">        cursor = conn.cursor()</span><br><span class=\"line\">        cursor.execute(sql, args)</span><br><span class=\"line\">        result = cursor.fetchone()</span><br><span class=\"line\">        conn.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fetch_all</span>(<span class=\"params\">self,sql,args</span>):</span></span><br><span class=\"line\">        conn = POOL.connection()</span><br><span class=\"line\">        cursor = conn.cursor()</span><br><span class=\"line\">        cursor.execute(sql, args)</span><br><span class=\"line\">        result = cursor.fetchall()</span><br><span class=\"line\">        conn.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p>以后在开发的过程中我们可以基于数据库连接池，基于pymysql，来实现自己个性化操作数据库的需求。</p>\n","more":"<h2 id=\"01-如何在python中操作数据库\"><a class=\"markdownIt-Anchor\" href=\"#01-如何在python中操作数据库\"></a> 01 如何在python中操作数据库</h2>\n<p>在后端开发中免不掉与数据库打交道，无非是使用<code>orm</code>或者原生<code>sql</code>来操作数据库。</p>\n<p>在python中通过原生sql操作数据库，主流就两种。</p>\n<ul>\n<li>使用pymysql模块：<code>pymysql</code>支持<code>python2.x</code>和<code>python3.x</code>的版本</li>\n<li>使用mysqldb模块：<code>mysqldb</code>仅支持<code>python2.x</code>的版本</li>\n</ul>\n<p>orm的使用以flask和django为例。</p>\n<ul>\n<li>flask使用的orm是基于<code>SQLAlchemy</code>（SQLAlchemy本就是orm），flask团队并在<code>SQLAlchemy</code>基础之上又封装了一个<code>Flask-SQLchemy</code>并予以应用 。</li>\n<li>django使用的orm是django自带的orm。</li>\n</ul>\n<p>orm的操作数据库的方式我们已经熟知了，这里我们聊一聊如何在web中使用原生sql操作数据库，以及会出现的问题。</p>\n<h2 id=\"02-在web中使用原生sqlpymysql操作数据库\"><a class=\"markdownIt-Anchor\" href=\"#02-在web中使用原生sqlpymysql操作数据库\"></a> 02 在web中使用原生sql(pymysql)操作数据库？</h2>\n<h3 id=\"21-在web中通过原生sql操作数据库会出现的问题\"><a class=\"markdownIt-Anchor\" href=\"#21-在web中通过原生sql操作数据库会出现的问题\"></a> 2.1 在web中通过原生sql操作数据库会出现的问题。</h3>\n<p><a href=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155710792-29404033..png\"><img src=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155710792-29404033..png\" alt=\"1554343834169\" /></a></p>\n<h4 id=\"示例1\"><a class=\"markdownIt-Anchor\" href=\"#示例1\"></a> 示例1：</h4>\n<p>把所有的数据库操作全部都放在了视图函数里面。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\">    CONN = pymysql.connect(host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">                           port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">                           user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">                           password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">                           database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">                           charset=<span class=\"string\">&#x27;utf8&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    cursor = CONN.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">    result = cursor.fetchall()</span><br><span class=\"line\">    cursor.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题</strong></p>\n<ul>\n<li>很多个用户并发的来请求，一个用户可以理解为一个线程，每个线程都会跟数据库建立连接，数据库承受不了这种量级的连接数。</li>\n</ul>\n<h4 id=\"示例2\"><a class=\"markdownIt-Anchor\" href=\"#示例2\"></a> 示例2</h4>\n<p>为了避免之前每个用户都建立连接，我们把数据库连接放到了全局变量里面，只会建立一次连接，但是依然会出现问题。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\">CONN = pymysql.connect(host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">                           port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">                           user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">                           password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">                           database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">                           charset=<span class=\"string\">&#x27;utf8&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span>():</span></span><br><span class=\"line\">    cursor = CONN.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">    result = cursor.fetchall()</span><br><span class=\"line\">    cursor.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题：</strong></p>\n<ul>\n<li>会出现线程安全问题，比如如果第一个用户拿到了连接给关闭了，而第二个用户正在进行查询，第二个用户查询的时候第一个用户把连接断了，会导致第二个用户出现问题。</li>\n<li>假设第一用户查询了一下表1，正准备获取查询的内容，这时第二个人查询了一下表2，由于cursor对象都是同一个，第一个人获取到的查询内容就是表2的内容了，所以也会出现线程安全问题</li>\n</ul>\n<h4 id=\"示例3\"><a class=\"markdownIt-Anchor\" href=\"#示例3\"></a> 示例3</h4>\n<p>为了避免之前的线程不安全，在示例2的基础上加上一把线程锁</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\">CONN = pymysql.connect(host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">                           port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">                           user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">                           password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">                           database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">                           charset=<span class=\"string\">&#x27;utf8&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> threading.Lock():</span><br><span class=\"line\">        cursor = CONN.cursor()</span><br><span class=\"line\">        cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">        result = cursor.fetchall()</span><br><span class=\"line\">        cursor.close()</span><br><span class=\"line\"></span><br><span class=\"line\">        print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题</strong>：</p>\n<ul>\n<li>根据代码可以发现，只是在示例2的基础上加了一把线程锁，确实是保证了线程安全，但是所有关于数据库操作的请求变成了串行，无法实现并发了。</li>\n</ul>\n<h4 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结：</h4>\n<ul>\n<li>如果直接连接坐在视图函数中，会导致每个用户都要创建连接，数据库承受不了这种量级的连接数。</li>\n<li>如果连接数据库的内容做成全局变量的话，无法保证线程安全。</li>\n<li>如果定义全局变量用于连接数据库，并且在线程中操作数据库内容加线程锁头，就会变成串行，无法保证并发</li>\n</ul>\n<p>所以我们既要控制数据库的连接数，又要保证线程安全，又要保证web的并发，这个时候最终的解决方案是数据库连接池。</p>\n<h3 id=\"21-什么是数据库连接池呢\"><a class=\"markdownIt-Anchor\" href=\"#21-什么是数据库连接池呢\"></a> 2.1 什么是数据库连接池呢？</h3>\n<p>数据库连接池概念：数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个，这项技术能明显提高对数据库操作的性能。</p>\n<p><strong>图解</strong>：</p>\n<p><a href=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155711355-1754252191..png\"><img src=\"https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191012155711355-1754252191..png\" alt=\"1553241307822\" /></a></p>\n<p>通俗的讲就是，假设数据库连接池中有5个连接对象，每个用户简单理解为一个线程，比如现在有6个用户同时来访问，6个线程去数据库连接池里面申请数据库的连接对象。前5个线程每个都申请到了连接对象去操作数据库，每个线程使用完了数据库连接对象会归还给数据库连接池，那么第6个线程会等待前5个线程归还连接对象给连接池，再具体一点是：假设第一个线程使用完了连接对象，那么此时6个线程才会结束等待，从而申请到连接对象，以此类推。</p>\n<h3 id=\"22-python数据库连接池dbutiles\"><a class=\"markdownIt-Anchor\" href=\"#22-python数据库连接池dbutiles\"></a> 2.2 Python数据库连接池DBUtiles</h3>\n<p>DBUtils 是Python的一个用于实现数据库连接池的模块。</p>\n<p>首先安装一下DBUtils模块。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install DBUtils</span><br></pre></td></tr></table></figure>\n<p>DBUtils连接池的两种连接模式：</p>\n<p>**模式一：**为每个线程创建一个连接，线程即使调用了close方法，也不会关闭，只是把连接重新放到连接池，仅供自己的线程再次使用，当线程终止时，连接会自动关闭。（不推荐使用，因为这样需要自己控制线程数量）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"><span class=\"keyword\">from</span> DBUtils.PersistentDB <span class=\"keyword\">import</span> PersistentDB</span><br><span class=\"line\"><span class=\"keyword\">from</span> threading <span class=\"keyword\">import</span> local</span><br><span class=\"line\"></span><br><span class=\"line\">POOL = PersistentDB(</span><br><span class=\"line\">    creator=pymysql,  <span class=\"comment\"># 使用链接数据库的模块</span></span><br><span class=\"line\">    maxusage=<span class=\"literal\">None</span>,  <span class=\"comment\"># 一个链接最多被重复使用的次数，None表示无限制</span></span><br><span class=\"line\">    setsession=[],  <span class=\"comment\"># 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]</span></span><br><span class=\"line\">    ping=<span class=\"number\">0</span>, <span class=\"comment\"># ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always</span></span><br><span class=\"line\">    closeable=<span class=\"literal\">False</span>,</span><br><span class=\"line\">    <span class=\"comment\"># 如果为False时， conn.close() 实际上被忽略，供下次使用，再线程关闭时，才会自动关闭链接。如果为True时， conn.close()则关闭链接，那么再次调用pool.connection时就会报错，因为已经真的关闭了连接（pool.steady_connection()可以获取一个新的链接）</span></span><br><span class=\"line\">    threadlocal=<span class=\"literal\">None</span>,  <span class=\"comment\"># 如果为none，用默认的threading.Loacl对象，否则可以自己封装一个local对象进行替换</span></span><br><span class=\"line\">    host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">    port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">    user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">    password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">    database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">    charset=<span class=\"string\">&#x27;utf8&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span>():</span></span><br><span class=\"line\">    conn = POOL.connection(shareable=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    cursor = conn.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">    result = cursor.fetchall()</span><br><span class=\"line\">    cursor.close()</span><br><span class=\"line\">    conn.close()</span><br><span class=\"line\"></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n<p>**模式二：**创建一批连接到连接池，供所有线程共享使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">from</span> DBUtils.PooledDB <span class=\"keyword\">import</span> PooledDB, SharedDBConnection</span><br><span class=\"line\">POOL = PooledDB(</span><br><span class=\"line\">    creator=pymysql,  <span class=\"comment\"># 使用链接数据库的模块</span></span><br><span class=\"line\">    maxconnections=<span class=\"number\">6</span>,  <span class=\"comment\"># 连接池允许的最大连接数，0和None表示不限制连接数</span></span><br><span class=\"line\">    mincached=<span class=\"number\">2</span>,  <span class=\"comment\"># 初始化时，链接池中至少创建的空闲的链接，0表示不创建</span></span><br><span class=\"line\">    maxcached=<span class=\"number\">5</span>,  <span class=\"comment\"># 链接池中最多闲置的链接，0和None不限制</span></span><br><span class=\"line\">    maxshared=<span class=\"number\">3</span>,  <span class=\"comment\"># 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。</span></span><br><span class=\"line\">    blocking=<span class=\"literal\">True</span>,  <span class=\"comment\"># 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</span></span><br><span class=\"line\">    maxusage=<span class=\"literal\">None</span>,  <span class=\"comment\"># 一个链接最多被重复使用的次数，None表示无限制</span></span><br><span class=\"line\">    setsession=[],  <span class=\"comment\"># 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]</span></span><br><span class=\"line\">    ping=<span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\"># ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always</span></span><br><span class=\"line\">    host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">    port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">    user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">    password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">    database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">    charset=<span class=\"string\">&#x27;utf8&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span>():</span></span><br><span class=\"line\">    conn = POOL.connection()</span><br><span class=\"line\">    cursor = conn.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">&#x27;select * from tb1&#x27;</span>)</span><br><span class=\"line\">    result = cursor.fetchall()</span><br><span class=\"line\">    conn.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n<h3 id=\"23-实际开发小应用案例\"><a class=\"markdownIt-Anchor\" href=\"#23-实际开发小应用案例\"></a> 2.3 实际开发小应用案例：</h3>\n<p><strong>案例目录：</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- app.py</span><br><span class=\"line\">- db_helper.py</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://app.py\">app.py</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> db_helper <span class=\"keyword\">import</span> SQLHelper</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&quot;/&quot;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span>():</span></span><br><span class=\"line\">    result = SQLHelper.fetch_one(<span class=\"string\">&#x27;select * from t1&#x27;</span>,[])</span><br><span class=\"line\">    print(result)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello World&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n<p>db_helper.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pymysql</span><br><span class=\"line\"><span class=\"keyword\">from</span> DBUtils.PooledDB <span class=\"keyword\">import</span> PooledDB</span><br><span class=\"line\">POOL = PooledDB(</span><br><span class=\"line\">    creator=pymysql,  <span class=\"comment\"># 使用链接数据库的模块</span></span><br><span class=\"line\">    maxconnections=<span class=\"number\">6</span>,  <span class=\"comment\"># 连接池允许的最大连接数，0和None表示不限制连接数</span></span><br><span class=\"line\">    mincached=<span class=\"number\">2</span>,  <span class=\"comment\"># 初始化时，链接池中至少创建的空闲的链接，0表示不创建</span></span><br><span class=\"line\">    maxcached=<span class=\"number\">5</span>,  <span class=\"comment\"># 链接池中最多闲置的链接，0和None不限制</span></span><br><span class=\"line\">    maxshared=<span class=\"number\">3</span>,  <span class=\"comment\"># 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。</span></span><br><span class=\"line\">    blocking=<span class=\"literal\">True</span>,  <span class=\"comment\"># 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</span></span><br><span class=\"line\">    maxusage=<span class=\"literal\">None</span>,  <span class=\"comment\"># 一个链接最多被重复使用的次数，None表示无限制</span></span><br><span class=\"line\">    setsession=[],  <span class=\"comment\"># 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]</span></span><br><span class=\"line\">    ping=<span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"comment\"># ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always</span></span><br><span class=\"line\">    host=<span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">    port=<span class=\"number\">3306</span>,</span><br><span class=\"line\">    user=<span class=\"string\">&#x27;root&#x27;</span>,</span><br><span class=\"line\">    password=<span class=\"string\">&#x27;123&#x27;</span>,</span><br><span class=\"line\">    database=<span class=\"string\">&#x27;pooldb&#x27;</span>,</span><br><span class=\"line\">    charset=<span class=\"string\">&#x27;utf8&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SQLHelper</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fetch_one</span>(<span class=\"params\">sql,args</span>):</span></span><br><span class=\"line\">        conn = POOL.connection()</span><br><span class=\"line\">        cursor = conn.cursor()</span><br><span class=\"line\">        cursor.execute(sql, args)</span><br><span class=\"line\">        result = cursor.fetchone()</span><br><span class=\"line\">        conn.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fetch_all</span>(<span class=\"params\">self,sql,args</span>):</span></span><br><span class=\"line\">        conn = POOL.connection()</span><br><span class=\"line\">        cursor = conn.cursor()</span><br><span class=\"line\">        cursor.execute(sql, args)</span><br><span class=\"line\">        result = cursor.fetchall()</span><br><span class=\"line\">        conn.close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<p>以后在开发的过程中我们可以基于数据库连接池，基于pymysql，来实现自己个性化操作数据库的需求。</p>\n","categories":[{"name":"flask","path":"api/categories/flask.json"}],"tags":[{"name":"flask","path":"api/tags/flask.json"},{"name":"python","path":"api/tags/python.json"}]}